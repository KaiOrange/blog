<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[图片由彩色渐变到黑白动画]]></title>
    <url>%2F2019%2F07%2F23%2F%E5%9B%BE%E7%89%87%E7%94%B1%E5%BD%A9%E8%89%B2%E6%B8%90%E5%8F%98%E5%88%B0%E9%BB%91%E7%99%BD%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[把图片变成黑白的效果使用Canvas就可以实现，那如何使图片渐变成黑白色呢？其实Canvas完全可以胜任，但是有更简单的办法就是CSS的滤镜。 首先上一下HTML的代码： 123&lt;img src="https://www.kai666666.top/2019/06/29/Canvas系列（8）：像素操作/lufei.jpeg" class="pic" /&gt; 此时的效果如下： CSS代码也很简单： 123456.pic &#123; transition: filter .8s ease;&#125;.pic:hover&#123; filter: grayscale(100%) ;&#125; 当然我们还可以添加多个滤镜，效果会更好，就比如再添加一个透明度变化的效果： 123456.pic &#123; transition: filter .8s ease;&#125;.pic:hover&#123; filter: grayscale(100%) opacity(66%);&#125; 更多滤镜效果请看这里，本示例代码请点击这里。]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS效果</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[构造方法或new返回该对象]]></title>
    <url>%2F2019%2F07%2F18%2F%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E6%88%96new%E8%BF%94%E5%9B%9E%E8%AF%A5%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[一个小技巧，调用构造方法或都new返回该对象： 1234567891011121314151617function Person()&#123; // ... // 不是new的时候this指向的是调用者 默认是window if (!(this instanceof Person)) &#123; return new Person(); &#125;&#125;Person.prototype.sayHello = function ()&#123; console.log("Hello World!");&#125;var lufei = Person();lufei.sayHello();var nami = new Person();nami.sayHello();]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>小技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VSCode支持Vue自动保存格式化的配置]]></title>
    <url>%2F2019%2F07%2F18%2FVSCode%E6%94%AF%E6%8C%81Vue%E8%87%AA%E5%8A%A8%E4%BF%9D%E5%AD%98%E6%A0%BC%E5%BC%8F%E5%8C%96%E7%9A%84%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[安装插件安装三个插件：Prettier - Code formatter、ESLint、Vetur。对应的插件图片如下： 修改配置文件MacOS使用Command + Sheft + P，windows使用Ctrl + Sheft + P搜索首选项:打开设置(json),然后把下面配置粘贴进去： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&#123; // 分号 "prettier.semi": false, "prettier.eslintIntegration": true, // 单引号包裹字符串 // 尽可能控制尾随逗号的打印 "prettier.trailingComma": "all", "prettier.singleQuote": true, "prettier.tabWidth": 2, // 关闭自带的格式化 "javascript.format.enable": false, // 让函数(名)和后面的括号之间加个空格 "javascript.format.insertSpaceBeforeFunctionParenthesis": true, // 启用eslint "eslint.enable": true, "eslint.validate": [ "javascript", "javascriptreact", &#123; "language": "vue", "autoFix": true &#125; ], // 格式化.vue中html "vetur.format.defaultFormatter.html": "js-beautify-html", // 让vue中的js按编辑器自带的ts格式进行格式化 "vetur.format.defaultFormatter.js": "vscode-typescript", "vetur.format.defaultFormatterOptions": &#123; "js-beautify-html": &#123; "wrap_attributes": "force-aligned" // 属性强制折行对齐 &#125; &#125;, "vetur.format.enable": true, "eslint.options": &#123; "extensions": [".js", ".vue"] &#125;, "eslint.autoFixOnSave": true, "editor.tabSize": 2, // 开启行数提示 "editor.lineNumbers": "on", // 去掉 vscode 自带的自动保存 ，vscode 默认也是 false "editor.formatOnSave": false, // vscode默认启用了根据文件类型自动设置tabsize的选项 "editor.detectIndentation": false, "editor.quickSuggestions": &#123; //开启自动显示建议 "other": true, "comments": true, "strings": true &#125;, "extensions.ignoreRecommendations": false, "window.zoomLevel": 1, "files.autoGuessEncoding": false, "workbench.sideBar.location": "left"&#125; 确保和项目配置不冲突如果项目配置和VSCode默认的配置有冲突可能会出现问题，请确保根目录下的.vscode/settings.json文件和上面的文件并不冲突，可以把.vscode/settings.json设置为一个空JSON。]]></content>
      <categories>
        <category>VSCode</category>
      </categories>
      <tags>
        <tag>配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Canvas系列（13）：实战--星空连线图]]></title>
    <url>%2F2019%2F07%2F17%2FCanvas%E7%B3%BB%E5%88%97%EF%BC%8813%EF%BC%89%EF%BC%9A%E5%AE%9E%E6%88%98-%E6%98%9F%E7%A9%BA%E8%BF%9E%E7%BA%BF%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[Canvas能做好多东西，本章就来一节实战性的东西吧。好多人来到这个博客的时候总是觉得后面这种点和线的背景很有意思，这种效果是怎么实现的呢，当然是使用Canvas了，我们这章就来实现一个简易版的这种星空连线图。 封装画点操作对于Canvas画图，好多大神都是使用面向对象的思想来做的，在游戏编程中，往往把拥有特定功能的对象称为精灵。我们这里先简单的对点这个对象做一定的封装： 123456789101112131415161718192021222324252627282930313233function Point(canvas,options) &#123; this.canvas = canvas; this.context = canvas.getContext("2d"); options = options || &#123;&#125;; this.x = options.x || 0; this.y = options.y || 0; this.radius = options.radius || 1; // x轴的速度 this.vx = options.vx || 0; // y轴的速度 this.vy = options.vy || 0; this.color = options.color || '#000000'; this.draw = function ()&#123; this.context.beginPath(); this.context.arc(this.x, this.y, this.radius, Math.PI / 180 * 0, Math.PI / 180 * 360); this.context.fillStyle=this.color; this.context.fill(); &#125; this.update = function ()&#123; // 匀速运动 this.x += this.vx; this.y += this.vy; // 超出边界反弹 if (this.x &lt; 0 || this.x &gt; canvas.width) &#123; this.vx = -this.vx; &#125; if (this.y &lt; 0 || this.y &gt; canvas.height) &#123; this.vy = -this.vy; &#125; &#125;&#125; 上面我们画点其实画的是一个半径很小的圆，当然也可以画长宽都很小的正方形，往往正方形只要fillRect一个API就可以了，而圆形往往需要好几个个API，所以效率上画正方形要比画圆更好，这里为了后面显示的更清楚就直接画圆了。 初始化Canvas我们现在通过DOM操作来初始化一个canvas，这样做的好处是有利于把星空连线图封装成一个组件，当然我们这里并不讲解如何封装成一个可复用的DOM组件，只讲解怎么实现。 1234567891011// 自己创建canvas 并通过DOM操作添加到body中var canvas = document.createElement("canvas")document.body.appendChild(canvas);var context = canvas.getContext('2d');// 设置样式属性canvas.style.position = "fixed";canvas.style.top = 0;canvas.style.left = 0;canvas.width = window.innerWidth;canvas.height = window.innerHeight;canvas.style.zIndex = "-1"; 我们手工创建一个Canvas并添加进来，最后设置宽高和样式，注意宽高使用canvas.width设置而不是canvas.style.width设置，这样不会缩放。 画一个点很简单了，直接上代码： 123456var p = new Point(canvas,&#123; x: 20, y: 20, radius:10, &#125;);p.draw(); 直接看效果： 画20个点现在我们画20个点吧： 12345678910111213141516171819var cWidth = canvas.width;var cHeight = canvas.height;var points = [];var pointsLength = 20;// 创建点for (var i = 0; i &lt; pointsLength; i++) &#123; var p = new Point(canvas,&#123; x: Math.floor(Math.random() * cWidth), y: Math.floor(Math.random() * cHeight), radius:10, &#125;) points.push(p);&#125;for (var i = 0; i &lt; points.length; i++) &#123; var p = points[i]; p.draw();&#125; 直接看效果，当然点的位置可能会不一样，毕竟是随机的： 让点动起来有了上几章知识的铺垫让点动起来很简单，当然我们现在不用那么大的点了，就是用默认的就可以了： 1234567891011121314151617181920212223242526272829303132var cWidth = canvas.width;var cHeight = canvas.height;var points = [];var pointsLength = 20;// 创建点for (var i = 0; i &lt; pointsLength; i++) &#123; var p = new Point(canvas,&#123; x: Math.floor(Math.random() * cWidth), y: Math.floor(Math.random() * cHeight), vx: Math.random() * 4 - 2, vy: Math.random() * 4 - 2, &#125;) points.push(p);&#125;function animate()&#123; // 清屏 context.clearRect(0, 0, canvas.width, canvas.height); for (var i = 0; i &lt; points.length; i++) &#123; var p1 = points[i]; p1.update(); p1.draw(); &#125; // 递归调用 requestAnimationFrame(animate);&#125;// 启动动画requestAnimationFrame(animate); 此时效果如下，图片有点放大： 添加连线添加连线也很简单，直接看完整代码吧： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// 自己创建canvas 并通过DOM操作添加到body中var canvas = document.createElement("canvas")document.body.appendChild(canvas);var context = canvas.getContext('2d');// 设置样式属性canvas.style.position = "fixed";canvas.style.top = 0;canvas.style.left = 0;canvas.width = window.innerWidth;canvas.height = window.innerHeight;canvas.style.zIndex = "-1";var cWidth = canvas.width;var cHeight = canvas.height;var points = [];var pointsLength = 20;var lineMaxLen = 100;// 创建点for (var i = 0; i &lt; pointsLength; i++) &#123; var p = new Point(canvas,&#123; x: Math.floor(Math.random() * cWidth), y: Math.floor(Math.random() * cHeight), vx: Math.random() * 4 - 2, vy: Math.random() * 4 - 2, &#125;) points.push(p);&#125;function animate()&#123; // 清屏 context.clearRect(0, 0, canvas.width, canvas.height); for (var i = 0; i &lt; points.length; i++) &#123; var p1 = points[i]; p1.update(); p1.draw(); // 划线 for (var j = i + 1; j &lt; points.length; j++) &#123; var p2 = points[j]; // 勾股定理 var l = Math.sqrt(Math.pow(p2.x - p1.x,2) + Math.pow(p2.y - p1.y,2)); if (l &lt; lineMaxLen) &#123; context.beginPath(); context.moveTo(p1.x, p1.y); context.lineTo(p2.x, p2.y); // 越远颜色越淡 context.strokeStyle='rgba(0,0,0,' + ((lineMaxLen - l) / lineMaxLen) + ')'; context.stroke(); &#125; &#125; &#125; // 递归调用 requestAnimationFrame(animate);&#125;// 启动动画requestAnimationFrame(animate); 此时效果如下： 源码请点击这里。 我们已经大致实现了我们的效果，当然还需要做的是监听window.resize事件，以动态设置Canvas的宽高；也可以自己添加事件，让鼠标顶点的位置也加一个点；甚至可以改变速度，当两个点靠近的时候速度加大，远离的时候速度减小；当然可以把这个效果封装成一个可以复用的组件，放在你的项目中。这些后续事情就交给你了，相信你可以的。 我们博客背景中使用的是canvas-nest.js，你也可以观摩一下它源码，实现方式和我们的大同小异。]]></content>
      <categories>
        <category>Canvas</category>
      </categories>
      <tags>
        <tag>Canvas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Canvas系列（12）：动画高级]]></title>
    <url>%2F2019%2F06%2F30%2FCanvas%E7%B3%BB%E5%88%97%EF%BC%8812%EF%BC%89%EF%BC%9A%E5%8A%A8%E7%94%BB%E9%AB%98%E7%BA%A7%2F</url>
    <content type="text"><![CDATA[通过前面章节的学习，我们已经学会了直线和部分曲线运动，同时我们也学会了加速、减速、摩擦力等操作。那么动画还有什么需要深入研究下去的呢？当然有，那就是让动画更加平滑，更细滑。 缓动动画在使用CSS3做变化的时候我们经常使用transition-timing-function，其中最有名的两个值就是ease-in和ease-out，那canvas种怎么实现这中如丝般细滑的缓动动画呢？看完本章你就知道了。缓动的公式如下： 当前速度 = (最终位置 - 当前位置) * 缓动系数。新的位置 = 当前位置 + 当前速度。 我们看一个简单的例子 123456789101112131415161718192021//...// 设置x的值放在最左边var ballX = ballRadius;var ballY = centerY;// x的速度 具体是多少在update的时候计算var vx;// 缓动系数var easing = 0.03;// 最终位置 在最右边var targetX = canvas.width - ballRadius;// 更新小球function updateBall()&#123; // 当前速度 = (最终位置 - 当前位置) * 缓动系数 vx = (targetX - ballX) * easing; // 新的位置 = 当前位置 + 当前速度 ballX += vx;&#125;//... 效果如下： 由上面公式中我们可以知道，缓动系数越大运动的越快。 带有角度的缓动动画带有角度的缓动动画也是一样的，只要把y轴上的分量也计算进去就可以了。 123456789101112131415161718192021222324//...// 设置起始位置在左上角var ballX = 0;var ballY = 0;// 速度 具体是多少在update的时候计算var vx,vy;// 缓动系数var easing = 0.03;// 最终位置 在右下角var targetX = canvas.width - ballRadius;var targetY = canvas.height - ballRadius;// 更新小球function updateBall()&#123; // 当前速度 = (最终位置 - 当前位置) * 缓动系数 vx = (targetX - ballX) * easing; vy = (targetY - ballY) * easing; // 新的位置 = 当前位置 + 当前速度 ballX += vx; ballY += vy;&#125;//... 效果如下： 由上可以，缓动动画只需要根据给定结束的位置就可以了，无需根据角度再进行计算，使用起来非常方便。通常由于缓动动画比摩擦力更细滑，所以减速后停来下的动画，基本上都用缓动动画。 缓动动画的其他使用场景缓动动画计算的过程其实一个简单数学推到，本身并不是什么高深的东西（当然做出来的效果确实很好）。我们的思维不能定势到只能做物体移动的动画，只要有从状态A平滑变化到状态B的场景都可以使用缓动动画，就比如宽高的变化，颜色的变化，透明度的变化等等。我们这里给一个小球半径变化的例子： 123456789101112131415161718192021//...// 小球画在中间位置var ballX = centerX;var ballY = centerY;// 缓动系数var easing = 0.03;// 最终位置 在右下角var targetBallRadius = 70;// 半径变化速度var vRadius;// 更新小球function updateBall()&#123; // 当前速度 = (最终位置 - 当前位置) * 缓动系数 vRadius = (targetBallRadius - ballRadius) * easing; // 新的位置 = 当前位置 + 当前速度 ballRadius += vRadius;&#125;//... 效果如下： 弹性动画缓动动画，当物体运动到终点的位置就会停下来；弹性动画，当物体运动到终点位置，会继续往前运动一下，然后反弹过来。那么怎么实现弹性动画呢？说出来你可能会不相信，缓动动画是速度使用缓动方程，而弹性动画是加速度使用缓动方程。也就是说： 当前加速度 = (最终位置 - 当前位置) * 弹性系数。新的速度 = 当前速度 + 当前加速度。新的位置 = 当前的位置 + 新的速度。 我们先来看一个例子： 1234567891011121314151617181920212223242526//...// 设置起始位置在左边var ballX = ballRadius;var ballY = centerY;// 初始速度var vx = 0;var vy = 0;// 加速度var ax;// 弹性动画系数var spring = 0.01;// 最终位置 在最右边var targetX = centerX;// 更新小球function updateBall()&#123; // 当前加速度 = (最终位置 - 当前位置) * 弹性系数 ax = (targetX - ballX) * spring; // 新的速度 = 当前速度 + 当前加速度 vx += ax; // 新的位置 = 当前的位置 + 新的速度 ballX += vx;&#125;//... 效果如下： 小球从左边，走到了中间，到中间的时候加速度是0，再往右一点，加速度是负数也就是减速，等减速到最右边的时候速度为0，然后向左边加速。通过上面公式我们发现第一个公式跟缓动公式是一样的，只是结果一个是加速度一个是速度，至于系数虽然这里叫的不一样，其实代表的含义差不多。 带有摩擦力的弹性动画上面的弹性动画是理想状态下的，就是物理上所说的绝对光滑的情况下才会发生，而现实中往往是具有摩擦力的。摩擦力我们之前学过，弹性动画我们也学过，如果把两者结合起来就是带有摩擦力的弹性动画，公式如下： 当前加速度 = (最终位置 - 当前位置) * 弹性系数。没有摩擦力的新的速度 = 当前速度 + 当前加速度。带有摩擦力的新的速度 = 没有摩擦力的新的速度 * 摩擦系数。新的位置 = 当前的位置 + 带有摩擦力的新的速度 1234567891011121314151617181920212223242526272829303132//...// 设置起始位置在左边var ballX = ballRadius;var ballY = centerY;// 初始速度var vx = 0;var vy = 0;// 加速度var ax;// 弹性动画系数var spring = 0.01;// 摩擦力系数var friction = 0.98;// 最终位置 在最右边var targetX = centerX;// 更新小球function updateBall()&#123; // 当前加速度 = (最终位置 - 当前位置) * 弹性系数 ax = (targetX - ballX) * spring; // 没有摩擦力的新的速度 = 当前速度 + 当前加速度 vx += ax; // 带有摩擦力的新的速度 = 没有摩擦力的新的速度 * 摩擦系数 vx *= friction; // 新的位置 = 当前的位置 + 带有摩擦力的新的速度 ballX += vx;&#125;//... 效果如下： 建议你自己写一写代码，或者自己把代码下载下来运行一下，代码地址：https://github.com/KaiOrange/canvas-demo。]]></content>
      <categories>
        <category>Canvas</category>
      </categories>
      <tags>
        <tag>Canvas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Canvas系列（11）：动画中级]]></title>
    <url>%2F2019%2F06%2F30%2FCanvas%E7%B3%BB%E5%88%97%EF%BC%8811%EF%BC%89%EF%BC%9A%E5%8A%A8%E7%94%BB%E4%B8%AD%E7%BA%A7%2F</url>
    <content type="text"><![CDATA[上一章我们讲了简单的动画是如何绘制的，如果没有看上一章的童鞋，请点这里，本章的内容也是接着上一章的内容，代码也只修改其中部分。 加速运动我上章中，涉及直线的运动，其速度都是恒定的，现在我们做一下加速的运行，同样的我们只给出核心的代码。 123456789101112131415161718//...// 设置x的值放在最左边var ballX = ballRadius;var ballY = centerY;// x的速度 初始值是0 然后逐渐加速var vx = 0;// 加速度var ax = 0.1; // 更新小球function updateBall()&#123; ballX += vx; // 改变速度 vx += ax;&#125;//... 效果如下： 那么减速运动怎么做呢？没错只要把加速度改一下就可以了，当然我们肯定要给一个初始速度： 123456789101112131415161718//...// 设置x的值放在最左边var ballX = ballRadius;var ballY = centerY;// x的速度 初始值是0 然后逐渐加速var vx = 7;// 加速度var ax = -0.1;// 更新小球function updateBall()&#123; ballX += vx; // 改变速度 vx += ax;&#125;//... 效果如下： 我们看到，小球先向右减速，当速度减到0的时候，然后又像左加速了，和物理课上讲的是一样的。 带角度的加速运动带角度的加速运动，和之前的一样，由于加速度不变，我们需要对加速度分解。 1234567891011121314151617181920212223242526//...// 设置球的起始位置在左上角var ballX = 0;var ballY = 0;// 初始速度var vx = 0;var vy = 0;// 角度var angle = 45;// 加速度是0,1var a = 0.1;// 计算加速度分量var ax = a * Math.cos(angle * Math.PI / 180);var ay = a * Math.sin(angle * Math.PI / 180);// 更新小球function updateBall()&#123; ballX += vx; ballY += vy; // 改变速度 vx += ax; vy += ay;&#125;//... 效果如下： 抛物线运动看到刚才的加速运动，我想问你自由落体运动怎么做？自由落体运动就是初速度为0，然后y方向上有一个加速度，我们第一个例子是x方向上的加速度，相信以你现在的实力，做出来是完全没问题的。现在我们看一下抛物线运动，抛物线运动是水平方向上的匀速直线运动，就可以了。 123456789101112131415161718192021//...// 设置球的起始位置在左下角var ballX = 0;var ballY = canvas.height;// 初始速度var vx = 3;// y方向初始速度向上var vy = -5;// y方向上的加速度是0.1（9.8太大了，所以就用了一个小的加速度）var ay = 0.1;// 更新小球function updateBall()&#123; ballX += vx; ballY += vy; // 改变y方向上的速度 vy += ay;&#125;//... 效果如下： 带反弹的抛物线运动增加一点难度，小球触碰到最下面那么将反弹，通常反弹会损失一点能量，我们就设置每次反弹后的速度是原来的80%。 12345678910111213141516171819202122232425262728293031//...// 设置球的起始位置在左下角var ballX = 0;// y先抬高一点var ballY = canvas.height - ballRadius;// 初始速度var vx = 2;// y方向初始速度向上var vy = -4;// y方向上的加速度是0.1（9.8太大了，所以就用了一个小的加速度）var ay = 0.1;// 符号表示方向 反弹后速度减小var bounce = -0.8;// 更新小球function updateBall()&#123; ballX += vx; ballY += vy; // 如果小球的高度 到最下面了 那么就设置最下面你的值 并且就反弹 if (ballY &gt; canvas.height - ballRadius) &#123; ballY = canvas.height - ballRadius; vy = vy * bounce; &#125; // 改变y方向上的速度 vy += ay;&#125;//... 效果如下： 摩擦力带有摩擦力的运动往往速度会逐渐变小直到为0（我们这里不考虑其他外力的作用），这和上面带有反方向加速度的减速运动很相似，但是减速运动速度为0的时候会反方向加速，带有摩擦力的运动不会反向加速。我们就改一改上面的那个减速的运动，直接把加速度改成摩擦力。 123456789101112131415161718//...// 设置x的值放在最左边var ballX = ballRadius;var ballY = centerY;// x的速度 初始值是0 然后逐渐加速var vx = 7;// 摩擦力系数var friction = 0.97;// 更新小球function updateBall()&#123; ballX += vx; // 速度减小 vx *= friction;&#125;//... 效果如下：]]></content>
      <categories>
        <category>Canvas</category>
      </categories>
      <tags>
        <tag>Canvas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Canvas系列（10）：动画初级]]></title>
    <url>%2F2019%2F06%2F30%2FCanvas%E7%B3%BB%E5%88%97%EF%BC%8810%EF%BC%89%EF%BC%9A%E5%8A%A8%E7%94%BB%E5%88%9D%E7%BA%A7%2F</url>
    <content type="text"><![CDATA[今天开始就要讲一些进阶的东西了，是不是很兴奋呢？ requestAnimationFrame所谓动画其实就是快读绘制图片，由于人的眼睛更不上屏幕绘制的速率，所以看到的就好像连着的一样，也就形成了动画，动画片就是这个原理，canvas中的动画也是这个原理。提到动画就不得不说一个函数了，那就是requestAnimationFrame。这是一个定时执行的函数，类似于setTimeout，只是间隔时间不再有我们自己手动去设定，而是由计算机自己去计算，这样比我们直接设定的误差更小（通常我们是定1000/60，约等于16.7毫秒，因为CPU的频率一般是60Hz，也就是1秒最多可以刷新60次界面）。但是往往浏览器对requestAnimationFrame的支持不够友好，那这就需要polyfill，通常一种简单的polyfill可以这么写： 123456789101112131415161718192021222324if (!Date.now) Date.now = function() &#123; return new Date().getTime(); &#125;;window.requestAnimationFrame = (function()&#123; var lastTime = 0; return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || function(callback) &#123; var now = Date.now(); var nextTime = Math.max(lastTime + 16, now); return window.setTimeout(function() &#123; callback(lastTime = nextTime); &#125;,nextTime - now); &#125;;&#125;)();// 与之对应的清空定时器的polyfillwindow.cancelAnimationFrame = (function()&#123; return window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || window.clearTimeout&#125;)(); 我们可以看到，他的做法是如果没有requestAnimationFrame那么使用setTimeout来做回退处理。通过上面我们可以看到callback有一个参数，就是时间，通常对于游戏等精度要求比较高的情况下我们使用这个时间和速度来计算当前帧的位置，这样可以有效避免，硬件配置所带来的优势。举个例子，比如我配置高可能比配置低的多画了几帧，那么同样的速度我就比别人走的快，而基于这个时间来计算的话就不会有问题了，如果配置低的少绘制几帧，那么时间间隔会变大相同的速度，距离也会边远。这就相当于直接跳过了中间几帧。当然对于这个时间的值不同浏览器实现的方式可能不一样，就比如谷歌的是从0毫秒开始逐渐递增的，有的浏览器是当前的毫秒数逐渐递增的，对于绘制图像的时候我们更多的是关注时间差，所以影响不是很大，就比如谷歌的第一帧传的时间可能是0，第二帧可能传的是17，而某些浏览器可能第一帧传的是1561859029000，第二帧传的是1561859029017，我们计算的时候往往是根据两者的差17来计算下一帧的位置。当然，对于一些简单与时间无关的动画特效，也可以不用关注这个时间，直接根据每次绘制时增加的速度去计算就好了，我们这里为了简单起见就不去动这个事件了。同时为了减少代码的长度我们就不使用polyfill了，如果是一个上线的项目最好使用上。 匀速直线运动匀速直线运动是最简单的动画，由于我们现在需要不断地檫除然后重新绘制，所以我们需要重新给出我们此时的JavaScript代码，如下，也可以在这里查看： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384var canvas = document.getElementById("canvas");var context = canvas.getContext('2d');var sW = 1;var lW = 4;var spacing = 10;// 绘制坐标系function drawCoordinate()&#123; context.beginPath(); for (var x = 0; x &lt; canvas.width; x+=spacing) &#123; context.moveTo(x, 0); if(x % (spacing * 5) === 0)&#123; context.lineTo(x, lW); &#125; else &#123; context.lineTo(x, sW); &#125; &#125; for (let y = 0; y &lt; canvas.height; y+=spacing) &#123; context.moveTo(0, y); if(y % (spacing * 5) === 0)&#123; context.lineTo(lW, y); &#125; else &#123; context.lineTo(sW, y); &#125; &#125; context.strokeStyle='black'; context.stroke();&#125;// 其他代码// 中心坐标(centerX,centerY)var centerX = canvas.width / 2;var centerY = canvas.height / 2;// 小球圆心的坐标var ballX = centerX;var ballY = centerY;// 小球的半径var ballRadius = 20;// 更新小球function updateBall()&#123; ballX += 1; // 如果超出去 那么回到初始位置 if (ballX &gt; 300 + ballRadius) &#123; ballX = -ballRadius; &#125;&#125;// 绘制小球function drawBall()&#123; context.beginPath(); context.arc(ballX, ballY, ballRadius, Math.PI / 180 * 0, Math.PI / 180 * 360); context.closePath(); context.fillStyle='orange'; context.fill();&#125;// 此时没有轨迹的绘制 所以就是一个空函数function drawLocus()&#123;&#125;function animate()&#123; // 清屏 context.clearRect(0, 0, canvas.width, canvas.height); // 绘制坐标系 drawCoordinate(); //绘制轨迹 有可能会用到 当前是空 drawLocus(); // 更新小球位置 updateBall(); // 绘制球 drawBall(); // 递归调用 requestAnimationFrame(animate);&#125;// 启动动画requestAnimationFrame(animate); 看到animate还是了吗，此函数是canvas动画的“套路”，一定要熟悉它，几乎所有动画相关的代码都有该函数的身影。此时的效果如下： 匀速圆周运动匀速圆周运动和匀速直线运动代码差不多，唯一不同的地方就是drawBall和updateBall这两个方法，当然涉及到一点小小的数学计算，这里直接给出变动的部分，变动的代码大多数也是相似的，你只要把注意力放在updateBall中就好了： 1234567891011121314151617181920212223242526// ...// 圆周运动半径var radius = 50;// 小球的角度var angle = 0;// 更新小球function updateBall()&#123; ballX = centerX + Math.cos(angle) * radius; ballY = centerY + Math.sin(angle) * radius; // 需要注意的是Math.cos和Math.sin中的参数是弧度而不是角度 // 也就是说2*Math.PI是一周约等于6.28 这里每次加0.08弧度 angle += 0.08;&#125;// 绘制轨迹function drawLocus()&#123; context.beginPath(); context.arc(centerX, centerY, radius, Math.PI / 180 * 0, Math.PI / 180 * 360); context.closePath(); context.strokeStyle='red'; context.stroke();&#125;// ... 出来的效果如下： 椭圆运动圆周运动和椭圆运动很相似，直接给代码： 1234567891011121314151617181920212223242526272829303132// ...// 椭圆运动半径var radiusX = 100;var radiusY = 50;// 小球的角度var angle = 0;// 更新小球function updateBall()&#123; ballX = centerX + Math.cos(angle) * radiusX; ballY = centerY + Math.sin(angle) * radiusY; angle += 0.08;&#125;// 轨迹function drawLocus()&#123; // 绘制椭圆 context.save(); context.beginPath(); // 将坐标系平移到圆心位置 context.translate(centerX, centerY ); // 把圆缩放后使之形成椭圆 context.scale(1, radiusY / radiusX); // 此时(0,0)是平移后的位置 也就是原坐标系的(centerX, centerY) context.arc(0, 0, radiusX, Math.PI / 180 * 0, Math.PI / 180 * 360); context.strokeStyle='red'; context.stroke(); context.restore();&#125;// ... 出来的效果如下： 左右来回运动通过观察我们可以发现，椭圆运动和圆周运动的区别就是椭圆运动的某一个轴的半径和另一个轴的半径是不同的，那么如果某一个周的半径是0会发生什么情况呢。这就是左右来回的运动。我们修改一下代码，并且把绘制轨迹的函数drawCoordinate去掉吧： 12345678910// 小球的角度var angle = 0;var radiusX = 100;// 更新小球function updateBall()&#123; ballX = centerX + Math.sin(angle) * radiusX; angle += 0.08;&#125; 出来的效果如下： 正弦运动上面是y不变，x利用三角函数计算的值，现在我们x每次增加一点，然后y轴使用三角函数，那就是正弦运动了。 12345678910111213141516// 小球的角度var angle = 0;var radiusX = 100;var radiusY = 50;var ballRadius = 20;// 更新小球function updateBall()&#123; ballX += 2; ballY = centerY + Math.sin(angle) * radiusY; angle += 0.08; // 超出去以后左边显示 if (ballX &gt; 300 + ballRadius) &#123; ballX = -ballRadius; &#125;&#125; 出来的效果如下： 带角度的匀速运动更多的时候我们会遇到带有一定角度的匀速运动，比如速度是每次更新2个像素，那么实际上x和y都是他的一个分量，现在看一下代码： 123456789101112131415161718// 小球圆心的坐标var ballX = 0;var ballY = 0;// 小球的半径var ballRadius = 20;// 这里写角度看起来比较直观var angle = 45;var spend = 2;// 更新小球function updateBall()&#123; // 绘制的时候需要把角度转换为弧度 var vx = Math.cos(angle * Math.PI / 180) * spend; var vy = Math.sin(angle * Math.PI / 180) * spend; ballX += vx; ballY += vy;&#125; 出来的效果如下： 我们可以看到小球在二维坐标系中的运动和速度的分解与合成有很大的关系。良好的数学和物理知识将帮助我们在这条路上走的更远。]]></content>
      <categories>
        <category>Canvas</category>
      </categories>
      <tags>
        <tag>Canvas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Canvas系列（9）：其他API]]></title>
    <url>%2F2019%2F06%2F29%2FCanvas%E7%B3%BB%E5%88%97%EF%BC%889%EF%BC%89%EF%BC%9A%E5%85%B6%E4%BB%96API%2F</url>
    <content type="text"><![CDATA[前面的内容讲了不少Canva的API，这章把剩下的API一讲吧。这个系列中以后基本不糊涉及新的API了，因为，这章完了我们就真的学完了！ 阴影Canvas中的阴影和CSS3中的阴影很像，通过本系列课程的学习，估计你已经发现了，CSS3的好多知识和Canvas是相通的。我们直接看一个例子： 12345678910111213141516171819202122// 阴影X偏移量 默认0context.shadowOffsetX=5;// 阴影Y偏移量 默认0context.shadowOffsetY=5;// 阴影颜色 默认透明context.shadowColor='orange';// 阴影模糊值 默认0context.shadowBlur=5;context.fillRect(10,10,50,50);// 阴影不模糊context.shadowBlur=0;context.fillRect(80,10,50,50);context.shadowBlur=5;// 使用在描边上context.strokeRect(150, 10, 50, 50);context.font='bold 30px 微软雅黑';context.shadowBlur=3;// 使用在文字上context.fillText("文字模糊", 10, 100); 结果如下： 由我们可以看到，阴影其实就是当前区域往左边偏移了一点，再往右边偏移了一点，然后给个颜色，给个模糊就可以了。当然偏移量可以是负值，表示方向，这个就不说了。同样由上我们可以知道阴影可以用在图形上也可以用在文字上，那么可以用在图片上吗？其实是不可以的，但是有方法可以，就是具有阴影地描边一个与图片大小位置全相同的矩形就可以了。 globalAlphaglobalAlpha是设置全局的透明度，取值范围是0~1，0表示透明，1表示不透明。我们之前没有设置所绘制的图形的透明度，但是都是不透明的，所以猜都能猜出来默认值是1。它的值可以是字符串类型，也可以数值类型，我们直接在上面代码中第十行中加入代码context.globalAlpha=0.5;看到的效果如下： 可以看到globalAlpha对它和它后面所绘制的图形是生效的，那么如何绘制完后恢复状态呢，还记得前面的内容吗？ globalCompositeOperationglobalCompositeOperation描述了2个图形交叉的时候是什么样子，它的值有很多，这里就盗一张很经典的图： 我们这里就给一个值为xor（异或）的例子吧： 1234567context.globalCompositeOperation='xor';context.fillStyle='orange';context.fillRect(10,10,50,50);context.fillStyle='blue';context.fillRect(35,35,50,50); 结果如下： clearRect在路径与状态那一章我们使用clip来裁剪区域，与裁剪相似的还有一个clearRect用来清空区域，如下： 12345678context.fillStyle='orange';context.fillRect(10,10,50,50);context.fillStyle='blue';context.fillRect(35,35,50,50);// 清空一个小区域context.clearRect(60, 60, 25, 25); 结果如下： clearRect用的挺多的，通常做动画的时候使用它来清空整个屏幕，然后再重新绘制图案： 12// 清空整个canvascontext.clearRect(0, 0, canvas.width, canvas.height); toDataURL与上面不同的是toDataURL并不是context上的方法，而是canvas对象的方法，来看个例子： 12345678910context.fillStyle='orange';context.fillRect(10,10,50,50);context.fillStyle='blue';context.fillRect(35,35,50,50);var src = canvas.toDataURL("image/png");var image = new Image();image.src = src;document.body.appendChild(image) 结果如下： canvas.toDataURL会转换为Base64格式的字符串，然后图片可以直接使用它，以显示出来。上面我们可以看到背景是不一样的，因为左侧的背景是我们通过CSS来设置的，而不是Canvas来绘制出来的。 至此，我们学完了Canvas几乎全部的API，恭喜你啊。此时，你又什么感想呢？是成就满满？还是感觉并没有学到些什么？如果你感觉成就满满，说明你是真的是学到了东西，如果还感觉没学到什么，也不要灰心，因为Canvas的学习并不仅仅是API，更多的是编程的一些技巧。好多时候我们学习编程其实学的只是一些语法和API而更多的经验还需要不断地在实践中去历练，往往一些编程技巧比语法和API要更重要，现在你学习的是HTML5中的Canvas，其实安卓、Java中的Swing、C++中的MFC（都是老技术了，新技术真心快学不懂了）等等绘制图片的技能都相差无几。我们后面的课程就会深入这些技能。]]></content>
      <categories>
        <category>Canvas</category>
      </categories>
      <tags>
        <tag>Canvas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Canvas系列（8）：像素操作]]></title>
    <url>%2F2019%2F06%2F29%2FCanvas%E7%B3%BB%E5%88%97%EF%BC%888%EF%BC%89%EF%BC%9A%E5%83%8F%E7%B4%A0%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[经常拍照的同学会使用图片处理软件，给自己的照片加上各种效果。图片处理软件也是软件，同样也是由代码写的，那么如何实现图片处理呢，这章我们就探讨一下这个问题。 canvas中像素处理涉及到3个方法，我们先来看一下API吧： 1234567891011121314// 1. 获取ImageDate 参数是左上角的左边(sx, sy)以及获取像素的宽度sw 和 高度sh// 他返回一个ImageData对象context.getImageData(sx, sy, sw, sh);// 2. 将处理后的ImageData设置到canvas中 由于是覆盖了canvas其中部分区域// 所以用的是put而不是set（并没有setImageData，put全部覆盖就可以相当于set）context.putImageData(imagedata, dx, dy);// 该方法还有可选参数context.putImageData(imagedata, dx, dy, dirtyX, dirtyY, dirtyWidth, dirtyHeight);// 3. 创建一个宽width 高height的ImageData对象context.createImageData(width, height);// 也可以根据已有的ImageData对象来创建context.createImageData(imagedata); 这几个API中，过来过去绕不过一个对象就是ImageData，ImageData对象到底是什么呢？他是一个描述了图片信息的对象，拥有三个属性：width、height、data。其中width、height就不用说了，分别是图片的宽度和高度，重点是这个data属性，他是一个Uint8ClampedArray对象，这个对象没听过？完全没问题，你就把他当做数组来处理，就可以了。这个“数组”是一个很长很长的一维数组，内容大概是[r0,g0,b0,a0,r1,g1,b1,a1...]这种形式的，其中r0,g0,b0,a0分别是图片左上角第一个像素的红绿蓝和透明度的值，后面分别是第二个像素，第三个像素等等的值。其中rgbb取值都是0~255，a如果是255表示不透明，之所以不按100来算是为了处理起来方便。 底片效果在写底片效果代码之前我们先绘制一张图片。 12345var image = new Image();image.src = "lufei.jpeg";image.onload = function ()&#123; context.drawImage(image, 0, 0,image.width / 2, image.height / 2);&#125; 由于我们的图片比较大，我们就缩小一半来展示（虽然此时图片仍然未显示完，不过不影响），此时的效果是这个样子的： 现在做底片处理： 12345678910111213141516var image = new Image();image.src = "lufei.jpeg";image.onload = function ()&#123; context.drawImage(image, 0, 0,image.width / 2, image.height / 2); var imageData = context.getImageData(0, 0, canvas.width, canvas.height); // 获取像素数据 var data = imageData.data; // 循环每次加4表示一个一个像素的处理，这个是常用套路 for (var i = 0; i &lt; data.length; i+=4) &#123; data[i + 0] = 255 - data[i + 0]; data[i + 1] = 255 - data[i + 1]; data[i + 2] = 255 - data[i + 2]; &#125; // 设置像素数据 context.putImageData(imageData, 0, 0);&#125; 出来的效果如下： 你或许会问为什么putImageData没有传入图片的宽度和高度呢，其实ImageData对象中本来就有高度和宽度，所以就无需传入了。另外还有一点需要注意，如果你在getImageData的时候控制台报这样的错误说明你跨域了： Uncaught DOMException: Failed to execute ‘getImageData’ on ‘CanvasRenderingContext2D’: The canvas has been tainted by cross-origin data. getImageData不允许访问非本域的图片，解决办法是自己启动一个服务，比如是用anywhere，使用方法就是在你的index.html所在的目录下的，使用终端输入下面两行命令，这样就可以使用服务打开了，记得把图片放在同一级目录下，图片在这里，点右键另存为同级目录下就可以了 12npm install -g anywhereanywhere 黑白效果直接上代码： 1234567891011121314151617var image = new Image();image.src = "lufei.jpeg";image.onload = function ()&#123; context.drawImage(image, 0, 0,image.width / 2, image.height / 2); var imageData = context.getImageData(0, 0, canvas.width, canvas.height); // 获取像素数据 var data = imageData.data; // 循环每次加4表示一个一个像素的过，这个是常用套路 for (var i = 0; i &lt; data.length; i+=4) &#123; var average = ( data[i + 0] + data[i + 1] + data[i + 2] ) / 3; data[i + 0] = average; data[i + 1] = average; data[i + 2] = average; &#125; // 设置像素数据 context.putImageData(imageData, 0, 0);&#125; 正如你看到的，像素处理都是一个模式，只是把中间处理像素的算法换了一下，此时的效果如下，是不是很酷？ 当然黑白效果还可以使用加权平均数来处理，这种网上推崇的比较多，毕竟上面这种比较泛白，处理起来也很简单，只需要把计算average的代码换一下： 1var average = data[i + 0] * 0.3 + data[i + 1] * 0.6 + data[i + 2] * 0.1; 效果： 变亮与变暗变量就是每个像素的颜色加上一个值，直接上代码： 1234567891011121314var image = new Image();image.src = "lufei.jpeg";image.onload = function ()&#123; context.drawImage(image, 0, 0,image.width / 2, image.height / 2); var imageData = context.getImageData(0, 0, canvas.width, canvas.height); var data = imageData.data; for (var i = 0; i &lt; data.length; i+=4) &#123; var brightness = 50; data[i + 0] += brightness; data[i + 1] += brightness; data[i + 2] += brightness; &#125; context.putImageData(imageData, 0, 0);&#125; 此时的效果如下： 你猜猜变暗是怎么处理的？没错就是减去一个值，你挺聪明的！！！直接修改var brightness = -50;，效果如下： 复古效果复古效果算法比较复杂，需要每一个颜色做加权处理，其算法是别人研究好久得出的，我们都是站在巨人的肩膀上： 12345678910111213var image = new Image();image.src = "lufei.jpeg";image.onload = function ()&#123; context.drawImage(image, 0, 0,image.width / 2, image.height / 2); var imageData = context.getImageData(0, 0, canvas.width, canvas.height); var data = imageData.data; for (var i = 0; i &lt; data.length; i+=4) &#123; data[i + 0] = 0.39 * data[i + 0] + 0.76 * data[i + 1] + 0.18 * data[i + 2]; data[i + 1] = 0.35 * data[i + 0] + 0.68 * data[i + 1] + 0.16 * data[i + 2];; data[i + 2] = 0.27 * data[i + 0] + 0.53 * data[i + 1] + 0.13 * data[i + 2];; &#125; context.putImageData(imageData, 0, 0);&#125; 效果如下： 蒙层蒙层就是某一个色道取平均值，另外2个色道为0就可以了，以红色蒙层为例： 1234567891011121314var image = new Image();image.src = "lufei.jpeg";image.onload = function ()&#123; context.drawImage(image, 0, 0,image.width / 2, image.height / 2); var imageData = context.getImageData(0, 0, canvas.width, canvas.height); var data = imageData.data; for (var i = 0; i &lt; data.length; i+=4) &#123; var average = ( data[i + 0] + data[i + 1] + data[i + 2] ) / 3; data[i + 0] = average; data[i + 1] = 0; data[i + 2] = 0; &#125; context.putImageData(imageData, 0, 0);&#125; 效果如下： 绿色蒙层和蓝色蒙层我相信你也会了，这里就不再给代码了。 透明效果我们说了这么多，都是以色道为例的，从来没有涉及到透明度，现在就给一个透明度的例子： 1234567891011 var image = new Image();image.src = "lufei.jpeg";image.onload = function ()&#123; context.drawImage(image, 0, 0,image.width / 2, image.height / 2); var imageData = context.getImageData(0, 0, canvas.width, canvas.height); var data = imageData.data; for (var i = 0; i &lt; data.length; i+=4) &#123; data[i + 3] = 0.5 * data[i + 3]; &#125; context.putImageData(imageData, 0, 0);&#125; 效果如下： 我们这里给的透明度细数是0.5，所以透明度变为原来的50%，你也可以修改为自己喜欢的数值。 创建ImageData上面我们一直在玩getImageData和putImageData，至于createImageData都没有说过，其实这个用的也并不多，这里给一个例子结束本章吧：12345678var imageData = context.createImageData(100, 100);var data = imageData.data;for (var i = 0; i &lt; data.length; i+=4) &#123; data[i + 0] = 255; // 下面这行很重要，默认创建后rgba的值都是0，所以也就是透明的 data[i + 3] = 255;&#125;context.putImageData(imageData, 10, 10); 效果如下，是不是又学会了一种画正方形的方法了？]]></content>
      <categories>
        <category>Canvas</category>
      </categories>
      <tags>
        <tag>Canvas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[证明0.999999999...等于1]]></title>
    <url>%2F2019%2F06%2F29%2F%E8%AF%81%E6%98%8E0-999999999-%E7%AD%89%E4%BA%8E1%2F</url>
    <content type="text"><![CDATA[最近看了一本书叫《极简算法史》，非常薄的一本书，里面的内容也是挺有意思的，现在分享一道证明题如何证明无限循环小数0.999999999…等于1，没错是等于1，高数上就是这么写的。 设x = 0.999999999...，那么10x = 9.999999999...。如果我们从10x减去x，可以得到： 10x - x = 9x = 9.999999999… - 0.999999999… = 9.000000000… 也就是9x = 9.000000000...因此x = 1，证明完毕。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Canvas系列（7）：形变]]></title>
    <url>%2F2019%2F06%2F22%2FCanvas%E7%B3%BB%E5%88%97%EF%BC%887%EF%BC%89%EF%BC%9A%E5%BD%A2%E5%8F%98%2F</url>
    <content type="text"><![CDATA[CSS3中有一个很重要的点，就是形变。他分为移动，缩放、旋转和倾斜。在Canvas中，形变都是基于坐标做的，所以，并没有直接的API支持倾斜，其它几种都是有独立的API来支持，命名和CSS是一样的。今天我们就看一下这几种吧。 平移平移是最简单的一种形变，我们直接来看一个例子吧： 12345678context.fillRect(10,10,20,20);// x平移20px y平移20pxcontext.translate(20, 20);context.fillRect(10,10,20,20);context.translate(20, 20);context.fillRect(10,10,20,20); 效果： 通过上面我们可以看到，平移（形变）移动的是坐标系，移动以后会以新的坐标系进行绘图，当多次平移（形变）以后每次都会以上一次的坐标系为准。此时你可能会问，那形变不是很危险吗，每次使用了形变就会使用新的坐标系，以后所有绘制的图片都会受到影响？没错是这样的，那改怎么解决呢？还记得之前的状态吗？现在给一个简单的例子： 12345678910111213// 形变前往往需要保存状态context.save();context.translate(20, 20);context.fillRect(10,10,20,20);// 形变结束，恢复之前的状态context.restore();// 此时以之前的坐标系绘制context.beginPath();context.fillStyle='red';context.fillRect(10,10,20,20); 效果： 缩放缩放也是相对于坐标系来说的，看一下这个例子： 1234567891011context.strokeStyle='red';context.lineWidth=10;context.strokeRect(20, 20, 50, 50);context.beginPath();// x是原来的1.5倍 y是原来的1.5倍context.save();context.scale(1.5, 1.5);context.strokeStyle='blue';context.strokeRect(20, 20, 50, 50);context.restore(); 效果： 可以看到，缩放改变的也是坐标系，在新的坐标系系中，宽度也放大了，一个像素已经不再是真正的一个像素了，而是放大以后的大小。所以可以看到都是10个像素的边框，宽度也不一样了。需要注意的是缩放的值大于1的时候是放大，0~1之间是缩小，1和原来是一样大的。 旋转直接上代码： 123456789101112context.strokeStyle='red';context.lineWidth=10;context.strokeRect(80, 20, 50, 50);context.beginPath();// x是原来的1.5倍 y是原来的1.5倍context.save();context.rotate(Math.PI / 180 * 45);context.strokeStyle='blue';context.strokeRect(80, 20, 50, 50);context.restore(); 效果： 可以看到旋转是基于坐标的原点的，如果不希望按照原点旋转的话，可以先平移再旋转。另外旋转也是根据弧度来旋转的而不是角度。 矩阵变换矩阵变换使用的API是context.transform(a, b, c, d, e, f);，所对应的矩阵的位置是下面这个样子： $$\left[\begin{matrix}a &amp; c &amp; e \\b &amp; d &amp; f \\0 &amp; 0 &amp; 1\end{matrix}\right] $$ 什么，看不懂？前方高能！！！多年前欠下的线性代数债，现在要还了。 对于形变，假设开始的坐标是($x_0$,$y_0$)，结束的坐标是($x_1$,$y_1$)，那么假如($x_1$,$y_1$)是$x_0$平移了e个单位，$y_0$平移了f个单位后得到的结果，那么$x_1$和$y_1$就等于如下：$$ x_1 = x_0 + e \\ y_1 = y_0 + f$$ 使用矩阵的笛卡尔积（左边值的第几行第几列中的值，就是右边第一个矩阵的第几行与第二个矩阵的第几列的乘积之和就是）的样子就是这个样子： $$\left[\begin{matrix}x_1 \\y_1 \\1 \\\end{matrix}\right] =\left[\begin{matrix}1 &amp; 0 &amp; e \\0 &amp; 1 &amp; f \\0 &amp; 0 &amp; 1\end{matrix}\right]\left[\begin{matrix}x_0 \\y_0 \\1 \\\end{matrix}\right] $$ 上面矩阵是平移时候的矩阵，将中间的矩阵带入矩阵的API有：context.transform(1, 0, 0, 1, e, f);。也就是说context.translate(e, f);等价于context.transform(1, 0, 0, 1, e, f);。 对于缩放，同样假设开始的坐标是($x_0$,$y_0$)，结束的坐标是($x_1$,$y_1$)，那么假如$x_0$缩放了a个单位，$y_0$缩放d个单位，那么$x_1$和$y_1$就等于如下：$$ x_1 = a * x_0 \\ y_1 = d * y_0$$ 使用矩阵的笛卡尔积就是这个样子： $$\left[\begin{matrix}x_1 \\y_1 \\1 \\\end{matrix}\right] =\left[\begin{matrix}a &amp; 0 &amp; 0 \\0 &amp; d &amp; 0 \\0 &amp; 0 &amp; 1\end{matrix}\right]\left[\begin{matrix}x_0 \\y_0 \\1 \\\end{matrix}\right] $$ 也就是说context.scale(a, d);等价于context.transform(a, 0, 0, d, 0, 0);。 旋转有点复杂，坐标($x_0$,$y_0$)和($x_1$,$y_1$)的意义和上面一下，旋转有如下公式（可以自行推到，并不难）： $$ x_1 = x_0 * cos\theta - y_0 * sin\theta \\ y_1 = x_0 * sin\theta + y_0 * cos\theta$$ 使用矩阵的笛卡尔积就是这个样子： $$\left[\begin{matrix}x_1 \\y_1 \\1 \\\end{matrix}\right] =\left[\begin{matrix}cos\theta &amp; -sin\theta &amp; 0 \\sin\theta &amp; cos\theta &amp; 0 \\0 &amp; 0 &amp; 1\end{matrix}\right]\left[\begin{matrix}x_0 \\y_0 \\1 \\\end{matrix}\right] $$ 也就是说context.rotate(angle);等价于context.transform(cos(angle), sin(angle), -sin(angle), cos(angle), 0, 0);。 所以我们上面的几个例子，我们做下面的等价替换，效果是一样的： 123456789101112context.translate(20, 20);// 等价于context.transform(1, 0, 0, 1, 20, 20);context.scale(1.5, 1.5);// 等价于context.transform(1.5, 0, 0, 1.5, 0, 0);context.rotate(Math.PI / 180 * 45);// 等价于var theta = Math.PI / 180 * 45;context.transform(Math.cos(theta), Math.sin(theta), - Math.sin(theta), Math.cos(theta), 0, 0); 除了transform外还有一个矩阵变换的方法叫setTransform，参数是一模一样的context.setTransform(a, b, c, d, e, f);。两者的区别是后者始终以最初的坐标做为参照，而transform以上次变换后的坐标做为参照（类似于前面的三个API）。]]></content>
      <categories>
        <category>Canvas</category>
      </categories>
      <tags>
        <tag>Canvas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Canvas系列（6）：绘制图片]]></title>
    <url>%2F2019%2F06%2F19%2FCanvas%E7%B3%BB%E5%88%97%EF%BC%886%EF%BC%89%EF%BC%9A%E7%BB%98%E5%88%B6%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[我们现在已经可以绘制好多东西了，不过在实际开发中，绘制最多的当然是图片了，这章我们就讲讲图片的绘制。 绘制图片绘制图片的API是drawImage，它的参数有三种情况： 12345678// 将图片绘制在canvas的(dX, dY)坐标处context.drawImage(Image, dX, dY);// 将图片绘制在canvas的(dX, dY)坐标处 图片大小缩放至dWidth * dHeightcontext.drawImage(Image, dX, dY, dWidth, dHeight);// 原图片将会按照 左上角坐标为(sX, sY) 大小为sWidth * sHeight裁剪// 然后再将图片绘制在canvas的(dX, dY)坐标处 图片大小缩放至dWidth * dHeight// 注意参数的位置！！context.drawImage(Image, sX, sY, sWidth, sHeight, dX, dY, dWidth, dHeight); 来一个例子： 12345var image = new Image();image.src = "https://www.kai666666.top/2019/06/19/Canvas系列（6）：绘制图片/lufei.jpeg";image.onload = function ()&#123; context.drawImage(image, 10, 10);&#125; 可以看到如下效果： 由上面可知，图片必须加载完成以后才可以绘制，所以我们放在onload里面了，当然也可以使用img标签，如果我们的代码是在图片加载完后加载的就不会有什么问题。现在我们修改一下绘制的参数，如下： 1context.drawImage(image, 10, 10, 100, 100); 出来的效果是这样的： 我们试一下参数最多的这个，如下： 1context.drawImage(image, 0, 0, 120, 120, 10, 10, 100, 100); 出来的效果是这样的： 当然drawImage除了可以绘制图片以外，还可以绘制canvas： 12345var canvas2 = document.createElement("canvas")var context2 = canvas2.getContext("2d");context2.fillRect(10,10,30,30);// 这里绘制的是canvas元素context.drawImage(canvas2, 0, 0); 出来的效果是这样的： 当然除了可以绘制canvas以外还可以绘制video不过每次只能绘制一屏，如果希望绘制的图形也可以播放的话，那么就要循环多次调用绘图了。同样的如果图片是GIF的也不会动态播放出来，而是会显示第一张。这两种情况很少用到，就不在重复了。 双缓冲技术：使用老的技术来绘图可能会有闪屏的现象，这往往是每绘制一屏的时候，然后用一个空白的屏幕来清理全屏，这就导致屏幕有的时候会一闪一闪的。解决这个问题的办法就是双缓冲技术。双缓冲技术说的是把画布先画在一个离线的canvas（或者图片）上，然后再把这个canvas绘制到用户看到的canvas上，因为每次看到的都是新canvas的覆盖，并不需要渲染空白屏，所以就不会有闪屏现象了，H5中的canvas是默认拥有双缓冲的，所以我们不需要再处理了。双缓冲技术更多的信息可以看这篇。 线性渐变我们之前使用过一个属性叫fillStyle，我们可以看到几乎我们都给的是某个颜色，那么为什么不直接叫fillColor呢，因为他除了颜色还可以设置其他的值，就比如线性渐变。定义一个线性渐变，大致是这个样子： 1234567// 创建一个线性渐变对象 （x1, y1）是起始坐标 （x2, y2）是结束坐标var gradient = context.createLinearGradient(x1, y1, x2, y2);// 在0~1的范围内 添加颜色 0是开始位置 1是结束位置gradient.addColorStop(number, 'color1');gradient.addColorStop(number, 'color2');// 设置线性渐变context.fillStyle = gradient; 现在来看一个例子 123456var gradient = context.createLinearGradient(0,0,300,150);gradient.addColorStop(0,"black");gradient.addColorStop(0.5,"white");gradient.addColorStop(1,"red");context.fillStyle = gradient;context.fillRect(10,10,280,130); 出来的效果是这样的： 径向渐变径向渐变和线性渐变很像，用法如下： 1234567// 创建一个径向渐变变对象 （x1, y1）是其实坐标 r1是起始半径 （x2, y2）是结束坐标 r2是结束半径var gradient = context.createRadialGradient(x1, y1, r1, x2, y2, r2);// 在0~1的范围内 添加颜色 0是开始位置 1是结束位置 和线性渐变是一样的gradient.addColorStop(number, 'color1');gradient.addColorStop(number, 'color2');// 设置径向渐变context.fillStyle = gradient; 现在来看一个例子 123456var gradient = context.createRadialGradient(150, 75, 10, 150, 75, 100);gradient.addColorStop(0,"black");gradient.addColorStop(0.5,"white");gradient.addColorStop(1,"red");context.fillStyle = gradient;context.fillRect(10,10,280,130); 出来的效果是这样的： 由上我们可以看出，渐变开始往前会使用渐变的第一个颜色，渐变结束往后会使用渐变的最后一个颜色。 图片背景style不仅仅可以是颜色和渐变，当然也可以是图片了，语法大概是这个样子的： 12345// 创建图片背景 Image就是一个图像 repetition是重复的关键字// repetition可选值有："repeat|repeat-x|repeat-y|no-repeat" 意思非常明显var pattern = context.createPattern(Image, repetition);// 设置图片背景context.fillStyle = pattern; 我们现在做一个文字带有背景的例子，效果如下： 具体代码： 12345678var image = new Image();image.src = "https://www.kai666666.top/2019/06/19/Canvas系列（6）：绘制图片/lufei.jpeg";image.onload = function ()&#123; var pattern = context.createPattern(image, "repeat"); context.font='30px 微软雅黑'; context.fillStyle = pattern; context.fillText("带有炫酷背景的文字", 10, 85);&#125;]]></content>
      <categories>
        <category>Canvas</category>
      </categories>
      <tags>
        <tag>Canvas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Canvas系列（5）：绘制文字]]></title>
    <url>%2F2019%2F06%2F19%2FCanvas%E7%B3%BB%E5%88%97%EF%BC%885%EF%BC%89%EF%BC%9A%E7%BB%98%E5%88%B6%E6%96%87%E5%AD%97%2F</url>
    <content type="text"><![CDATA[通过前面的学习，我们已经可以绘制简单的图形了。这篇文章主要讲的是，canvas绘制文字，那我们开始吧。 绘制文字绘制文字的API和之前的差不多，也是分为stroke和fill，一个是描边文字，一个是填充文字，具体API如下，是不是和strokeRect和fillRect挺类似的： 1234567// 描边文字，其实就是镂空字体喽// 参数中 text是写什么文字 (x, y)决定了写的位置// maxWidth给了一个最大的宽度 是非必填的 如果填了并且超出了则会缩放宽度（注意不是换行）context.strokeText(text, x, y, maxWidth);// 填充文字，其实就相当于写文字喽context.fillText(text, x, y, maxWidth); 随便给一个例子： 12345678// 设置字体大小，为了看的更清楚context.font='30px 微软雅黑';// 描边context.strokeText("这里是strokeText", 20, 40);// 填充context.fillText("这里是fillText", 20, 80);// 带有最大宽度的填充context.fillText("这里是fillText", 20, 120,100); 出来的效果如下： CSS是如何实现镂空字的呢？请看这篇文章。 measureText有的时候我们需要让文字水平居中，而上面你也看到了，绘制文字传递的参数x和y是基于左上角的坐标来绘制的（默认情况下），这就需要计算一下文字的宽度，measureText就是用来干这事的。他返回一个TextMetrics对象，什么，没听过这个对象？完全没关系，这个对象很简单，名字你可以不用记，但你要记得该对象的一个特征就好了，那就是这个对象只有一个属性，连方法都没有，这个属性就是width。API如下： 12// 传入文本返回一个带有width的对象，width表示文本的宽度context.measureText(text); 给一个文本居中的例子： 1234context.font='30px 微软雅黑';var text = "文本水平居中";// 居中的x坐标是：( canvas.width - context.measureText(text).width ) / 2context.fillText(text, ( canvas.width - context.measureText(text).width ) / 2, 80); 上面canvas就是canvas标签的dom元素，然后水平的x需要计算一下，y这里就随便给了一个80px。效果如下： font属性接下来我们说一下文字相关的一些属性，上面说了一个font属性，font属性的语法和CSS中font属性的语法是一样的，你有没有发现canvas和CSS有好多地方都是想通的，具体API如下： 1context.font='&lt;font-style&gt; &lt;font-variant&gt; &lt;font-weight&gt; &lt;font-size / line-height&gt; &lt;font-family&gt;'; 其中font-style的值有normal，italic（斜体，使用斜体文字倾斜），oblique（斜体，将正常的文字通过算法倾斜，因此没有斜体字体的属性也可以倾斜）。font-variant的值有normal，small-caps。font-weight的值有normal，bold，bolder，lighter，100~900（100到900的值）。我们修改一下上面例子中的font属性，如下： 1context.font='italic bold 30px 微软雅黑'; 效果如下： textAlign属性textAlign属性表示文字的对齐方式，它的可选值有：start，end，center，left，right。这五个，其中start和left很像，end和right也很像，一般情况下他们基本上是一样的效果，但是有的国家的文字并不是从左往右写的，而是从右往左写，就像我国古代一样，这个时候start就相当于right了。换句话说start和end会检测文本顺序是ltr(left to right)还是rtl(right to left)，你可以给DOM元素加一个属性direction=“rtl”然后看看效果。由于现在我国和大多数的国家都是ltr，所以这里就不对这两个属性做详细的描述了，现在给一个另一种让文字水平居中的方法： 123456context.font='30px 微软雅黑';var text = "文本水平居中";// 设置文本居中context.textAlign='center';// 然后在画布水平的中间位置绘制文字context.fillText(text, canvas.width / 2, 80); 效果如下： textBaseline属性textBaseline属性描述了文本基线的位置。他的值有：alphabetic（默认，使用字母表的基线），top，hanging（悬挂基线），middle，ideographic（表意基线），bottom。 这里给一个文字水平垂直居中的例子： 12345context.font='30px 微软雅黑';var text = "文本水平垂直居中";context.textAlign='center';context.textBaseline='middle';context.fillText(text, canvas.width / 2, canvas.height / 2); 效果如下：]]></content>
      <categories>
        <category>Canvas</category>
      </categories>
      <tags>
        <tag>Canvas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Canvas系列（4）：线条操作]]></title>
    <url>%2F2019%2F06%2F16%2FCanvas%E7%B3%BB%E5%88%97%EF%BC%884%EF%BC%89%EF%BC%9A%E7%BA%BF%E6%9D%A1%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[通过前三章的学习，你几乎可以绘制出任何图形了，但是却不会画一条虚线，也是够惨的。今天的内容很简单，只简绍3个属性和1个方法，准备好了吗？ 线条的粗线lineWidth是改变线条的粗线的，默认是一个像素： 123456789101112131415161718context.beginPath();context.moveTo(20, 50);context.lineTo(280, 50);context.lineWidth=1;context.stroke();// 如果这里没有beginPath 你猜猜这三条线的宽度分别是多少context.beginPath();context.moveTo(20, 75);context.lineTo(280, 75);context.lineWidth=5;context.stroke();context.beginPath();context.moveTo(20, 100);context.lineTo(280, 100);context.lineWidth=10;context.stroke(); 结果如下： 如果上面没有beginPath那么后面线描边的时候也会把之前的绘制一下，那么三条先最终的宽度就都是10了。lineWidth也可用于矩形和圆弧上，只要画线的地方都可以，如下： 1234context.beginPath();context.rect(20, 20, 60, 60);context.lineWidth=20;context.stroke(); 结果如下： 我们可以看到改变lineWidth，矩形的大小也变了，目前的宽度是矩形的宽度 + lineWidth（左边多了一半，右边也多了一半）。 线帽样式线帽样式由lineCap来定义，它有三个值butt | round | square分别对应无线帽 | 圆角 | 方形，默认是butt（无线帽），如下： 1234567891011121314151617181920context.beginPath();context.moveTo(20, 50);context.lineTo(280, 50);context.lineWidth=10;context.lineCap='butt';// 无线帽 默认值context.stroke();context.beginPath();context.moveTo(20, 75);context.lineTo(280, 75);context.lineWidth=10;context.lineCap='round'; // 圆角context.stroke();context.beginPath();context.moveTo(20, 100);context.lineTo(280, 100);context.lineWidth=10;context.lineCap='square'; // 方形context.stroke(); 结果如下： 线帽样式对于越宽的线条效果越明显，所以上面线宽给了一个10。同时可以看到线帽给的不一样，宽度其实也是有点不同的。线帽只是对线条2端点的样式做了处理，如果是线条中间的那么就不生效了： 1234567context.beginPath();context.moveTo(100, 50);context.lineTo(200, 50);context.lineTo(200, 100);context.lineWidth=20;context.lineCap='round';context.stroke(); 结果如下： 如果要改变中间的样子那该怎么办？那么就是用lineJoin。 线条交界处样式线条交界处样式由lineJoin来决定，它有三个值miter | bevel | round分别是尖角 | 斜角 | 圆角，默认是miter。斜角时如下： 12345678context.beginPath();context.moveTo(100, 50);context.lineTo(200, 50);context.lineTo(200, 100);context.lineWidth=20;context.lineCap='round';context.lineJoin='bevel';context.stroke(); 结果如下： 如果context.lineJoin=&#39;bevel&#39;;改为context.lineJoin=&#39;round&#39;;时，结果如下： 绘制虚线虚线是由细小的实线和空白组成，绘制虚线使用setLineDash方法，它接收一个数组作为参数，数组是实线和空白的长度： 12345context.beginPath();context.arc(150, 75, 60, Math.PI / 180 * 0, Math.PI / 180 * 360);// 实线和空白比例是10px : 5pxcontext.setLineDash([10,5]);context.stroke(); 结果如下： 值的一提的是，如果不传数组的话，那么就会报错；传一个空数组的话，会按照实线去绘制；如果数组只有一个元素的话，那么就是实线和空白依次按这个元素大小来绘制；如果多个元素的时候就是交替循环来间隔。]]></content>
      <categories>
        <category>Canvas</category>
      </categories>
      <tags>
        <tag>Canvas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Canvas系列（3）：路径与状态]]></title>
    <url>%2F2019%2F06%2F16%2FCanvas%E7%B3%BB%E5%88%97%EF%BC%883%EF%BC%89%EF%BC%9A%E8%B7%AF%E5%BE%84%E4%B8%8E%E7%8A%B6%E6%80%81%2F</url>
    <content type="text"><![CDATA[前两章我们学的是基本图形的描边和填充，学完基本图形绘制以后就会绕不过2个概念就是路径和状态，本章我们看看这一块的内容。 beginPathbeginPath表示开始一个路径，我们在上一章画弧的时候用到过好多次，他的API非常简单： 1context.beginPath(); 开始路径有2层意思，一个就是本次绘制的起点是新的（不再是上次结束的点了），另外一个意思就是绘制的样式也是新的（不再与之前的样式有关联）。对于第一条上一个章节我们已经见识过了，如果不开始一个新的路径那么描边弧线的时候就会有一条上次绘制结束到弧线开始时的连线（当然moveTo可以避免，但需要计算，不方便）。现在考虑这么一个需求，我们需要画3条线，线的颜色分别是红绿蓝，使用之前的知识，你应该可以的，你先试一下？或许你写的代码是这样的： 1234567891011121314context.moveTo(10, 50);context.lineTo(290, 50);context.strokeStyle='#FF0000';context.stroke();context.moveTo(10, 75);context.lineTo(290, 75);context.strokeStyle='#00FF00';context.stroke();context.moveTo(10, 100);context.lineTo(290, 100);context.strokeStyle='#0000FF';context.stroke(); 执行后的结果大概是这个样子的： 我们发现颜色是错误的，但是又不清楚哪里有问题了。难道是它的API有bug了吗?我们打断点，然后单步执行，看看上面三个stroke依次执行后的效果： 我们可以看到，当代码执行到红色以后是对的（虽然把坐标系也变成红色了）；然后绿色执行后把绿色这条渲染对了，但是又用绿色渲染了一下红色的那条线，使得红色的线变成2者的叠加色了；当绿色的执行完了以后，把最后一条线描边成绿色，但是又把前面的也渲染了一遍，所以最终的颜色就是我们之前看到的。要让新的线不在绘制之前的就用beginPath来开启一个新的路径。看看我们使用后的效果： 1234567891011121314151617context.beginPath();context.moveTo(10, 50);context.lineTo(290, 50);context.strokeStyle='#FF0000';context.stroke();context.beginPath();context.moveTo(10, 75);context.lineTo(290, 75);context.strokeStyle='#00FF00';context.stroke();context.beginPath();context.moveTo(10, 100);context.lineTo(290, 100);context.strokeStyle='#0000FF';context.stroke(); 效果： 总结一下：使用beginPath路径将不再与之前的联系，绘制时也不再绘制之前的（所以已绘制图案的样式不再叠加）。 closePathclosePath是闭合路径，注意是闭合路径而不是结束路径，虽然目前的位置是在beginPath后面，但是两者没什么关系，它并不是endPath（没有这个）。 现在有需求，需要描边一个45°的扇形，你以你现在的技术完全可以胜任，大笔一挥： 12345context.beginPath();context.moveTo(150, 75);context.arc(150, 75, 80, Math.PI / 180 * 0, Math.PI / 180 * 45);context.lineTo(150, 75);context.stroke(); 效果不错，挺满意的。现在我们观察倒数第二行代码，我们使用context.lineTo(150, 75);画了一条回到圆心（起点）的线。在stroke的时候回到起点可以绘制出一个闭合的图形，这种操作实在太多了，为了简化这个步骤，我们就可以使用closePath。现在直接把context.lineTo(150, 75);替换为context.closePath();你会发现效果是一样的，这样就省去了自己计算起点位置的步骤了。我强烈建议在闭合路径的时候使用closePath。需要顺便提醒一下，填充（fill）的时候，对于一个终点和起点没有闭合的路径，默认会闭合了再去填充（不然没得玩了），如下。当然如果还有其他没有闭合的时候（就比如平行的2个线段），那么就真的没的完了，他也“不会”绘制了。 1234context.beginPath();context.moveTo(150, 75);context.arc(150, 75, 80, Math.PI / 180 * 0, Math.PI / 180 * 45);context.fill(); 上面没有闭合，直接填充，结果和闭合了以后是一样的效果： 点是否在路径内部跟路径有关的一个常见问题，就是需要判断点是否在一个路径的内部。canvas考虑到大家的这个需要，给了大家提供了这样的API： 12// 坐标(x, y)是否在路径内部 如果在就返回true否则就返回falsecontext.isPointInPath(x, y); 这里需要注意的有三点： 如果一个路径结束和开始的位置没有闭合，判断的时候会按照闭合来处理（如果结束点和开始点闭合后整个路径还没有闭合，那么就返回false）。 strokeRect和fillRect不会保留绘制的矩形路径，所以isPointInPath不能对他们进行判断，可以使用rect代替。 如果刚刚在路径所处的直线上，那么需要根据线宽来决定，如果路径内与线中心一侧的时候那么返回false，其他的时候返回true，举个例子比如线宽是1，那么如果在线上，说明是内部；如果线宽是3，那么在内部和前2个像素上是内部，外面的一个像素是外部。 看了第三条你可能又会问那么就只想知道是否在线上怎么办，那就可能会用到另一个API了： 12// 坐标(x, y)是否在描边上 如果在就返回true否则就返回falsecontext.isPointInStroke(x, y); 此时你可能还会问，你只想知道是否在路径的内部，根本不关心在不在描边上，那么怎么办？给你提醒一下，把这两个API综合起来判断就可以了，相信你一定可以做到的。此外这两个API比较简单就不再给出例子了，感兴趣的同学可以自己研究下。 裁剪区域路径学完了我们先额外插播一个小知识，就是裁剪区域，先看个例子，我们先描边一个圆形，再填充一个矩形： 12345678context.beginPath();context.arc(150, 75, 40, Math.PI / 180 * 0, Math.PI / 180 * 360);context.stroke();// 开始新的路径 与之前的不再有关系 如果不开始 下面的fill的时候会把上面圆也fill了context.beginPath();context.rect(150, 75, 40, 40);context.fill(); 此时结果如下： 然后我们按照圆的样子裁剪矩形，稍微修改一下代码： 12345678910context.beginPath();context.arc(150, 75, 40, Math.PI / 180 * 0, Math.PI / 180 * 360);context.stroke();// 按照圆裁剪context.clip();context.beginPath();context.rect(150, 75, 40, 40);context.fill(); 此时结果如下，简直完美： 这里需要注意的是裁剪也是基于路径来的，所以strokeRect和fillRect是不生效的。我们再画一个矩形： 123456789101112131415context.beginPath();context.arc(150, 75, 40, Math.PI / 180 * 0, Math.PI / 180 * 360);context.stroke();// 按照圆裁剪context.clip();context.beginPath();context.rect(150, 75, 40, 40);context.fill();// 再画一个矩形context.beginPath();context.rect(190, 35, 80, 80);context.fill(); 结果： 什么放错图了？没错，就是这个样子！我们分析一下，上面画了一个圆，然后描边了，然后按照圆裁剪，那么下面画的第一个矩形会按照圆来裁剪，没问题。然后画了第二个矩形，那么问题来了，这个矩形也被裁剪了！那么怎么让第二个矩形不再裁剪呢？如果后面的一直都被裁剪，那么每裁剪一次就缩小一点点距离，那多痛苦。 状态的保存于恢复接下来就是我们的处理办法了，如果裁剪前把当前状态保存了，然后裁剪完第一个矩形后，再把状态恢复了，不是很好的解决了这个问题吗？canvas也是这么做的： 12345678910111213141516171819context.beginPath();context.arc(150, 75, 40, Math.PI / 180 * 0, Math.PI / 180 * 360);context.stroke();// 保存状态context.save();context.clip();context.beginPath();context.rect(150, 75, 40, 40);context.fill();// 恢复之前保存的状态，即没有裁剪时那个状态context.restore();context.beginPath();context.rect(190, 35, 80, 80);context.fill(); 一个刷新，完美： 通常裁剪前一般都会保存路径的，裁剪完后，一般都会恢复的。除此之外保存与恢复也可以用在某些样式状态上，还可以用在形变（后面会讲到的，类似与CSS3的transform）的状态保存上。]]></content>
      <categories>
        <category>Canvas</category>
      </categories>
      <tags>
        <tag>Canvas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Canvas系列（2）：曲线图形]]></title>
    <url>%2F2019%2F06%2F15%2FCanvas%E7%B3%BB%E5%88%97%EF%BC%882%EF%BC%89%EF%BC%9A%E6%9B%B2%E7%BA%BF%E5%9B%BE%E5%BD%A2%2F</url>
    <content type="text"><![CDATA[上一章学的是直线图形的描边和填充，本章我们看看对曲线图形的描边和填充。 圆弧画弧的API如下 12345678// 圆心：(x,y) 半径：radius 起始弧度：startRadian 结束弧度:endRadian 画弧方向：anticlockwisecontext.arc(x, y, radius, startRadian, endRadian, anticlockwise);// 上述起始弧度和结束弧度都是我们数学上学的弧度就是2 * PI是一圈，// 通常我们习惯上喜欢用角度作为单位，也就是360°是一圈// 所以我们更多的使用一下公式// 起始角度：startAngle 结束角度：endAngleccontext.arc(x, y, radius, Math.PI / 180 * startAngle, Math.PI / 180 * endAngle, anticlockwise); 我们先画一个弧线： 123context.beginPath();context.arc(150, 75, 60, Math.PI / 180 * 0, Math.PI / 180 * 90);context.stroke(); 结果如下： 我们的代码是加在上一章最后的坐标系中的，如果直接使用arc画弧的话，那么起始点是上一个绘制的结束，也就是绘制坐标系的结束位置，为了让之前的代码的结束不在作为本次绘制的开始，我们使用了新的APIcontext.beginPath();，用来开启一个新的路径，路径相关的知识会在下一章跟大家分享。我们这里绘制了一个圆心是(150,75)，半径是60，从0度到90度的弧。由上我们可以看出弧的角度是按照我们高中学的坐标系来的。所以，学习是有用的！！！ 填充弧线： 123context.beginPath();context.arc(150, 75, 60, Math.PI / 180 * 0, Math.PI / 180 * 90);context.fill(); 结果如下： 描边结果有没有和你预想的不太一样，你脑海中的问题或许下章给你简答的。现在先考虑一下上面最后一个参数anticlockwise，它如果是true的时候表示逆时针绘制，false的时候是顺时针绘制，默认什么都不传相当于传了个undefined，当然也就是false了。我们把这个值设置为true，看看结果，如下： anticlockwise还有一个用处就是制作图形中的图形，可以看一下之前的那篇非零环绕规则。 圆画圆很简单只要把上面的结束度数改成360就可以了，直接给出结果： 另一种画弧的方法canvas提供了另一种画弧的方法，就是arcTo: 12// (x1, y1) 表示控制点的坐标 （x2, y2）是结束点的坐标 radius是圆弧半径context.arcTo(x1, y1, x2, y2, radius); 那么你会问起始点的坐标是哪里呢？其实起始点的坐标就是上一次绘制结束时的坐标或者moveTo后的坐标，这个规则跟前面的lineTo是一样的，后面的贝塞尔曲线也跟这是一个道理。arcTo画出来的弧线半径是radius，该弧线与起始点或终点与控制点所在的直线相切。当然看一个例子 1234context.beginPath();context.moveTo(210, 75);context.arcTo(210, 135, 150, 135, 60);context.stroke(); 效果如图： 我把说明也绘制上，如下： 我们上面给的半径是60px，这个半径刚刚好，因为是我本人精心计算的，如果半径不能构成一个很好的弧线那会是什么样子呢？下面分别给出半径是120px和30px的样子： 由上可以知道圆弧是一定会过起始点的，有可能会经过终点，起始点有可能是处于切线上。arcTo是没有顺时针画弧还是逆时针画弧的控制参数的，因为起始点控制点和终点就可以决定画弧的方向。 arcTo画弧的应用arcTo画弧最常见的场景就是画圆角矩形。上节课我们画了一个正方形不知道还有人记得不，不记得的可以会去看看代码，现在我们就把那个矩形加一个半径是20px的圆角。代码如下： 1234567891011121314// 之前绘制的是起点在(90, 15)宽和高都是120的矩形// 所以矩形的右下角是(210, 135)// 现在加4个20px圆角context.moveTo(90 + 20, 15);context.lineTo(210 - 20, 15);context.arcTo(210, 15, 210, 15 + 20, 20);context.lineTo(210, 135 - 20);context.arcTo(210, 135, 210 - 20, 135, 20);context.lineTo(90 + 20, 135);context.arcTo(90, 135, 90, 135 - 20, 20);context.lineTo(90, 15 + 20);context.arcTo(90, 15, 90 + 20, 15, 20);context.fillStyle='blue';context.fill(); 二次贝塞尔曲线我们使用arcTo的时候参数中有一个控制点，一个结束点，还有一个半径。圆弧的圆心到圆弧和起点或终点到控制点的切线的距离刚好是半径。而二次贝塞尔曲线画出的是更好的曲线，它没有半径的限制，画出的弧线并不是某个圆的一部分。它的API如下： 12// 其中(cpx, cpy)是控制点 （x, y）是终点context.quadraticCurveTo(cpx, cpy, x, y); 同样我们画上面的四分之一圆可以这么写，效果与之前是完全一样的： 1234context.beginPath();context.moveTo(210, 75);context.quadraticCurveTo(210, 135, 150, 135);context.stroke(); 我们稍微修改一下代码： 12345context.beginPath();context.moveTo(210, 75);// 结束点修改了一下context.quadraticCurveTo(210, 135, 100, 135);context.stroke(); 三次贝塞尔曲线大家猜猜，三次贝塞尔曲线是几个控制点，几个结束点？哈哈，当然是2个控制点，1个结束点了，怎么可能有2个结束的位置呢！API如下： 12// 其中(cp1x, cp1y)是控制点1 (cp2x, cp2y)是控制点2 （x, y）是终点context.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y); 给个例子： 1234context.beginPath();context.moveTo(50, 75);context.bezierCurveTo(100, 20, 200, 130, 250, 75);context.stroke(); 效果图如下：]]></content>
      <categories>
        <category>Canvas</category>
      </categories>
      <tags>
        <tag>Canvas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Canvas系列（1）：直线图形]]></title>
    <url>%2F2019%2F06%2F15%2FCanvas%E7%B3%BB%E5%88%97%EF%BC%881%EF%BC%89%EF%BC%9A%E7%9B%B4%E7%BA%BF%E5%9B%BE%E5%BD%A2%2F</url>
    <content type="text"><![CDATA[在前端最令人兴奋的技术莫过于Canvas技术。它可以制作出更加绚丽的效果，甚至完全可以胜任游戏开发。最近我也在学习Canvas相关的技术，总是想拿出来跟大家一起分享分享，由于这块技术比较庞大，所以我就分章节一章一章地跟大家分享。这几章节中我们并不涉及webGL相关的知识，感兴趣的可以自己玩一玩。 我们的全部代码可以在这个网址查看：https://github.com/KaiOrange/canvas-demo。 快速上手在HTML5中，涌现了很多的新技术，其中最令人兴奋的就是Canvas。我就不卖关子了，直接快速使用吧。首先我们有这样的HTML代码： 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Canvas系列&lt;/title&gt; &lt;style type="text/css" &gt; #canvas&#123; background: #f5f5f5; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas id="canvas"&gt;&lt;/canvas&gt; &lt;script type="text/javascript"&gt; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 这个是我们的模板，如果你想好好学习的话，建议你也创建一个index.html文件，并且把代码敲一下。此时我们看到的效果是这个样子的： canvas标签默认的样式是大小为300 * 150像素、没有背景色的行内替换元素，类似于img标签。我们这里为了看上去更加方便给了一个背景元素。要使用canvas进行绘图，需要使用JavaScript去控制它，现在我们就在script标签中添加JavaScript代码来绘制一条直线： 12345678// 1. 获取canvas元素var canvas = document.getElementById("canvas");// 2. 获取上下文对象var context = canvas.getContext('2d');// 3. 绘制图片context.moveTo(10, 75);context.lineTo(290, 75);context.stroke(); 出来的效果如下： 通过上面几行代码我们知道canvas绘图的时候无非就是三个步骤： 获取canvas元素 获取上下文对象 绘制图片 第一步获取canvas元素其实就是DOM操作，获取到的canvas元素也是DOM元素，DOM元素就有大量的DOM相关的属性和方法了，可以使用console.table(canvas);打印一下。canvas中最重要的属性和方法莫过于这四个： 属性或方法 含义 width 长度 height 宽度 getContext(‘2d’) 获取2D上下文，如果是WebGL可以传webgl toDataURL() 获取转换的位图字符串（后面会简绍） 第二步中传递的是2d，这样会返回一个绘制2D图形的上下文，也就是context对象。因为canvas是画布的意思，有人也把上下文对象成为画笔。如果要绘制3D图像怎么办？可以传一个webgl来获取WebGL的上下文，这样就可以绘制3D效果了（WebGL是基于OpenGL，是已存在的一套技术，所以并没有使用3D来获取3D的上下文，有可能以后开发出性能更加优越的3D绘制系统的话可能会取代WebGL，当然短期内是不会的，毕竟WebGL加上部分库用起来也很方便，性能也挺不错的）。 最重要的第三步，canvas提供了大量的API供我们绘制图片，我们下面几个章节会重点简绍。 最后需要注意2点： 计算机中除了WebGL等少数坐标系的y轴是向上的，其他的都是向下的，我们的2d上下文的y轴就是向下的。 设置canvas大小的时候使用HTML中的属性设置，而不要使用CSS设置，如果使用CSS设置后会缩放。 对于第二条特别重要，我们试着修改CSS： 12345#canvas&#123; background: #f5f5f5; width: 150px; height: 300px;&#125; 现在的效果是： 可以看到线段仍然是居中的，而且明显粗了，这是缩放导致的。使用HTML控制如下： 1&lt;canvas id="canvas" width="150" height="300"&gt;&lt;/canvas&gt; 绘制2条线段绘制线段用到2个API： 1234// 将画笔移动到(x1, y1)的坐标context.moveTo(x1, y1);// 画线到(x2, y2)的坐标context.lineTo(x2, y2); 通过上述2步以后其实并没有画线，通过上面可以看到还需要调用context.stroke();，这一点一定要记住。为什么要多此一步呢？一方面是因为一次性统一绘制会减少内存的开销，另一个原因是因为canvas不仅仅支持描边（stroke）还支持填充（fill），后面马上就会遇到了。 那如果画2条线呢？我们就重复使用上面两个API，如下： 123456context.moveTo(10, 65);context.lineTo(290, 65);context.moveTo(10, 85);context.lineTo(290, 85);context.strokeStyle='blue';context.stroke(); 效果： 你可能已经看到了我们这里使用了context.strokeStyle=&#39;blue&#39;;把线段的颜色改成蓝色（而不是默认的黑色），这个属性一定要在stroke之前调用，否则都描边结束了才设置，是不会生效的，这样改变的是下面描边的颜色，就好比你拿黑色的笔画了一条线，结果你又拿起了一只蓝色的笔，然后你希望你刚刚话的线是蓝色的。这里的strokeStyle是描边的样式，它的值可以是特殊颜色值如blue等，也可以是rab(0,0,255),还可以是raba(0,0,255,1),更可以是#0000FF，甚至是图片、渐变等（后面会讲到，所以没有叫strokeColor）。 描边矩形矩形就是4条线段，我们直接开画： 123456context.moveTo(90, 15);context.lineTo(210, 15);context.lineTo(210, 135);context.lineTo(90, 135);context.lineTo(90, 15);context.stroke(); 效果： 我们绘制了一个宽高都为120px的矩形（其实也就是一个正方形）。由上可知lineTo划线的起点是上一次移动到的地方或者上次划线结束的地方，因此我们没有必要每次都moveTo当前位置。由于矩形是非常重要的图形，所以canvas提供了一个更加方便的API： 12// 绘制一个起始坐标为:(x, y) 宽度:width 高度:height 的矩形context.rect(x, y, width, height); 使用新的API绘制： 12context.rect(90, 15, 120, 120);context.stroke(); 这下是不是容易多了？什么？还不容易，那么给你简绍一个更简单的API： 123// 绘制一个起始坐标为:(x, y) 宽度:width 高度:height 的矩形// 使用strokeRect将会直接绘制出来 而不需要在调用stroke()了context.strokeRect(x, y, width, height); 使用新的API绘制： 1context.strokeRect(90, 15, 120, 120); 填充矩形填充和描边一样，只是描边的时候调用的是stroke，填充的时候是fill，看一个例子： 1234567context.moveTo(90, 15);context.lineTo(210, 15);context.lineTo(210, 135);context.lineTo(90, 135);context.lineTo(90, 15);context.fillStyle='blue';context.fill(); 效果： 是不是很简单，你可能已经注意到了修改填充矩形的样式是fillStyle，其用法跟描边时是一样的。此时你会有一个疑问，那么描边矩形有简写吗？如果你问的话，说明你的学习力还是很不错的，先给你一个赞。当然有了，直接上代码： 12345678// 简写1context.rect(90, 15, 120, 120);context.fillStyle='blue';context.fill();// 简写2context.fillStyle='blue';context.fillRect(90, 15, 120, 120); 如果既要描边又要填充怎么办呢？可以看这个： 12345context.rect(90, 15, 120, 120);context.strokeStyle='red';context.stroke();context.fillStyle='rgba(0,0,255,0.5)';context.fill(); 效果如下，像不像CSS给了一个背景和一个边框？没错填充就类似于是设置背景，描边就类似于给个边框。 绘制简易坐标系为了更方便后面你的使用我们绘制一个简易的坐标系吧，效果如下： 完整HTML代码如下，后面的如果不出意外的话就会在这个基础上绘制： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Canvas系列&lt;/title&gt; &lt;style type="text/css" &gt; #canvas&#123; background: #f5f5f5; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas id="canvas" &gt;&lt;/canvas&gt; &lt;script type="text/javascript"&gt; var canvas = document.getElementById("canvas"); var context = canvas.getContext('2d'); var sW = 1; var lW = 4; var spacing = 10; for (var x = 0; x &lt; canvas.width; x+=spacing) &#123; context.moveTo(x, 0); if(x % (spacing * 5) === 0)&#123; context.lineTo(x, lW); &#125; else &#123; context.lineTo(x, sW); &#125; &#125; for (let y = 0; y &lt; canvas.height; y+=spacing) &#123; context.moveTo(0, y); if(y % (spacing * 5) === 0)&#123; context.lineTo(lW, y); &#125; else &#123; context.lineTo(sW, y); &#125; &#125; context.stroke(); // 其他代码 &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>Canvas</category>
      </categories>
      <tags>
        <tag>Canvas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[建立自己的npm镜像服务器]]></title>
    <url>%2F2019%2F06%2F15%2F%E5%BB%BA%E7%AB%8B%E8%87%AA%E5%B7%B1%E7%9A%84npm%E9%95%9C%E5%83%8F%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[好多公司有这样的需求，需要把公司内部的依赖包放在npm服务器上这样安装的时候直接使用npm install安装了。同时，公司可能不希望自己的代码被别人看到，那么建立自己的npm镜像服务器是最好的选择。最近我也遇到同样的问题，希望在自己公司内部搭建一个npm镜像服务器。 搭建这个服务器有两种办法，一种是使用cnpm来做，优点是功能强大；还有一种解决办法就是使用verdaccio。 cnpm方式是最常用的，网上有好多简绍，这里就不重复了，感兴趣的可以看这篇，我们这里讲的是第二种方法。为什么使用第二种方式呢，因为这种方式实在是太简单了（开箱即用），对于一般的小公司来说这种方式非常合适。如果你看过其他的资料可能会了解到一个库叫sinopia也是干这事的，它和verdaccio的用法基本差不多，实际上verdaccio就是forksinopia的，而verdaccio能活下来，说明verdaccio要更加优秀，所以我们这里就主要简绍一下verdaccio的使用。 部署 下载全局依赖 1npm install -g verdaccio 启动 1verdaccio 好了吗？没错好了！这个时候你已经可以访问了。当你启动以后不出意外的话，会有4行日志，大概是这个样子的： 这4行是比较重要的，其中第一行是verdaccio的配置文件路径，第二行和第三行是插件加载信息，第二行是镜像源的URL，通常我们需要开放到整个内网中，那么我们不太希望使用localhost去访问，更多情况下希望使用IP或者域名去访问，这个时候就得修改配置了。 修改配置打开配置文件/Users/admin/.config/verdaccio/config.yaml（具体文件路径，可以参考上面第一行日志），然后在最下面添加一行：listen: 0.0.0.0:4873。 另外我们的国内的镜像源一般是使用淘宝镜像去下载东西的，那么可以把我们的镜像源的来源设置为淘宝的镜像源，这样可以提高国内的下载速度。做法也是修改这个配置文件，找到uplinks下面两行把url替换一下，具体的如下： 1234# a list of other known repositories we can talk touplinks: npmjs: url: https://registry.npm.taobao.org/ 配置好后就大功告成了，把配置文件保存一下，然后重启verdaccio（命令行中Ctrl + C，然后重新运行verdaccio命令）。 此时可以在浏览器键入http://你的IP:4873/或者http://localhost:4873/来访问管理页面。 切换到我们的镜像源切换镜像源很简单，只要一行代码就搞定： 1npm config set registry http://你的IP:4873/ 当然为了更好的对镜像源管理我建议使用nrm来切换： 123npm install -g nrmnrm add verdaccio http://你的IP:4873/nrm use verdaccio 这里我把我们的镜像源命名为verdaccio，你也可以定义为你喜欢的名字，公司内部建议使用公司的名称。你也可以使用nrm ls查看所有镜像源，还可以使用nrm use XXX换成镜像源列表中的其他镜像源。 使用pm2启动我们上面直接运行命令verdaccio启动的，这样是没问题的，有的时候为了更加严谨的方式可以使用pm2。pm2是一款非常优秀的进程管理工具，使用方式也很简单，我们这里就直接使用它启动了，更多使用方法可以看这里。 12npm install -g pm2pm2 start verdaccio 上传一个依赖包说了这么多我们现在可以开发一个自己的包，然后上传到我们的镜像源上。首先切换到我们自己的源上，然后添加用户（我们镜像源上的用户不是npm镜像源中的用户）。添加用户使用下面命令，然后依次输入用户名、密码、邮箱。输入密码的时候是看不到字符的，尽管输入就可以了。当操作完了会输出一行日志Logged in as orange on http://你的IP:4873/.表示创建用户并登录成功了。 1npm adduser 此时你也可以使用npm whoami查看你是否登录成功了。 此时你可以创建一个依赖包，然后上传上去了。我们来定义一个依赖包的名称，比如就叫my-package，找一个目录输入下面命令： 123mkdir my-packagecd my-packagenpm init npm init后会让你输入其他的配置项，比如包名是my-package，其他的直接按回车，最后输入一个yes就可以了。此时你会看到目录下多了一个文件夹叫my-package里面有个文件package.json。 接下来我们在my-package文件夹下，创建一个index.js的文件。输入下面的代码，当然如果想输入其他的就看自己的喜好了： 123module.exports = function ()&#123; console.log(`Hello World!`);&#125; 此时我们已经创建好了一个非常简单的包，然后我们可以上传了，使用shell/cmd进入我们的my-package目录，然后输入命令： 1npm publish 此时如果看到+ my-package@1.0.0说明已经上传成功了，你可以用浏览器打开http://你的IP:4873/你会发现确实多了一个包。 如果你在之后上传的时候一定要修改package.json的version字段，并且要大于现在，否则不能上传。也可以使用命令npm version 1.0.1直接修改版本号。 使用开发好的依赖包现在我们使用我们的依赖包，首先在与my-package同级目录下再建一个文件夹，比如叫use-package。同样使用npm init去初始化我们的项目。并且创建一个index.js的文件。 此时你可以安装我们刚才发布的那个包了： 1npm install my-package 并且在index.js中输入以下代码： 12const helloWorld = require('my-package')helloWorld() 此时大功告成，在shell/cmd中打开use-package文件夹，然后输入命令node index，如果看到Hello World!说明我们上传的依赖已经可以使用了。]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>npm镜像</tag>
        <tag>npm源</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《高效能程序员的修炼》读书笔记]]></title>
    <url>%2F2019%2F05%2F26%2F%E3%80%8A%E9%AB%98%E6%95%88%E8%83%BD%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E4%BF%AE%E7%82%BC%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[《高效能程序员的修炼》写的是给程序员的一些建议。书中并没有涉及到代码，而是编码之外的一些提高程序员技能的技巧，而这些技巧往往是程序员所缺乏的。作者Jeff Atwood也是一个大牛，如果你没有听说过他，那么你肯定听说过他创立的一个网站：https://stackoverflow.com。 入门须知程序员的八种境界： 境界 具体描述 典型程序员 不朽程序员 人已经离开了这个世界，但是他的代码却依然活着 Dijkstra,Knuth 成功程序员 不仅拥有广泛的知名度，同事还运营者一家不错的公司，甚至控制着整个产业链 比尔盖茨,Carmack 知名程序员 其他程序员或多或少听说过你，并且对所在领域有积极影响 阮一峰,张鑫旭 胜任程序员 你的能力使得你在工作中游刃有余，公司因你的加盟而得到了提升 你的某个领导！ 普通程序员 基本上能够应对一般的编程能力，并且不认为自己能够成为杰出的程序员 你们公司那种不错的程序员！ 业余程序员 有创意、热衷于编码，往往是一些有前途的学生或实习生 就比如我！ 低调程序员 服务于某家公司，没有什么成就，写代码仅仅是一份工作 你们公司最多的那种程序员 烂程序员 技能匮乏，所做的东西给同事带来痛苦 你们公司因为技术不行被开除的程序员 成为一名杰出的程序员其实跟写代码没有太大的关系，做程序员确实需要一些技能，还要有坚韧不拔的精神。除此之外，最重要的还要有良好的沟通技巧。这里说的沟通不仅仅是人与人的沟通还包括纸面沟通，比如写博客等。写作的过程真的就是一次探索之旅，而且它会贯穿人的一生。 把一堆烂代码搞定的艺术每一天，你一定要一起床就热情澎湃。否则，你就只是在打工。金钱对社区是有毒的。传统的“胡萝卜加大棒”（使驴子前进就在他前面放一个胡萝卜或者用大棒驱赶他）的激励方式仅仅对于那些重复的、机械的任务有效。（言外之意对软件开发是没有效果的，软件开发需要的是内在的激励，要让程序员主动地去投入自己的事业中。正因为如此，作者在创立Stack Overflow的时候并不在乎员工什么时候来上班，或者如何安排工作时间，也不会事无巨细的样样过问，正如你所见的Stack Overflow是成功的）。如果你想造一艘船，就不要催着工人们去收集木材，分派工作，发号施令。你应该教会他们的是对无边无际大海的渴望。如果想在某方面有所提高，最好的办法就是勤加练习。但是，如果你只顾着埋头写代码，连讨论、反思或者学习的时间都没有，你将得不到真正的进步。你必须在磨练工艺与思考如何提高工艺之间找到一个适当的平衡点。沿着那条路下去，一定要快。如果有什么东西挡住了你的去路请绕开它（快速迭代）。尽量避免多任务做事。 高效编程的原则永远都是自己的错：程序员最基本的意识就是你写的代码在任何时候出现了问题，那一定是你的错（而往往不是电脑的问题）。大道至简：如果你热爱编码，而且爱的情真意切，那你就应该惜墨如金。避免写注释：最好的注释就是代码。学会阅读源码：不管文档上面怎么说，源代码才是最终的事实，是你所能找到的最好的，最确定的，最新的文档。向伙伴或互联网求助：即使没有得到你想要的答案，强迫自己去完整地解释自己的问题，常常也会引领你进入新的视野或者为你带来新的发现。创新以人为本：在软件开发领域，执行意味着专注于构成你的应用程序的微小细节。你的团队能通过电梯测试吗：60秒之内，清晰地解释他们在做什么，以及为什么人们会在意他们正在做的事情。性能致胜：网站载入和显示的速度越慢，使用他的人就会越少（要么很快，要么已经死去）。 招聘程序员须得其法怎样招聘程序员： 首先要求通过几个简单的“Hello World”在线测试。 提出要看看他们的文件夹。 只雇认同公司文化的人。 进行一个周祥的结构化电话面试。 给他们一个“视镜”项目。 找个房间面谈，并最后定夺。 上面没有哪条保证完全奏效的。 面试官应尽最大努力去避免的2大错误： 不要让候选人主导面试过程。 小心只会一招的“小马驹”。 软件开发者最擅长的就是学习。工作经验年数与编程技能之间是没有必要联系的。 促使团队紧密协作团队的问题往往都是人的问题。如果你想提高团队的工程水平，你需要一个领导，而不是靠一个训导员去强制执行。最有效的一种技术领导就是以身作则。要有结对编程或者代码评审。我们应该以怀疑的态度去看待会议，把它当成是一种降低工作效率的风险。如何开好会议： 会议绝对不应该超过一个小时，否则应判以死刑。 每个会议都应该有一个清晰的目标。 在开会之前预先做好功课。 把会议变成可选的。 在会议结束时概括一下待办事项。 如何对待“换苹果”（一个坏苹果放在一筐好苹果中，那么很快这框苹果都会坏掉）： 你不必和团队中的每个人都成为朋友（不要充当老好人）。 如果你的团队主管或者经理没有处理项目中的“坏苹果”，那他就是玩忽职守。 把某个人从团队中调走是很痛苦的，但是当你意识到你本应该在6个月前就把某人调走时，此时你已经更加痛苦了（没有必要留情面）。 远程开发需要遵循的原则： 远程团队最小2个人，需要找到伙伴（废话）。 只有非常热爱编程的资深程序员才可以申请远程开发的职位（主观能动性要强）。 为了保证效率，远程团队需要完全自治，并且还需要一个有强烈远景和执行力的领导者。 程序员的高效工作场所可以提高效率的基础设施： 每个程序员都应该有两台显示屏。 每个程序员都应该有一台快速的电脑。 每个程序员都应该自己选择鼠标和键盘。 每个程序员都应该有一把舒适的椅子。 每个程序员都应该能快速接入互联网。 每个程序员都应该有安静的工作环境。 对于公司来说这几个基本权利很容易做到，这些要求并不过分。一个公司愿意付给一个开发人员6W~10W美元的薪水（在美国），却用糟糕的工作条件以及破烂的硬件设施摧残他，这令我难以置信（作者说的，不是我说的，虽然我也很认同，哈哈）。 购买一张优质的桌子和一把优质的椅子会是你作为一名软件开发者所能做的最好的投资之一了。 程序员标准坐姿： 显示器的顶端应该与眼睛平齐。 桌子的表面应该和肚脐基本持平。 脚应该在地板上平放，并且膝关节呈90°。 当你打字的时候，手腕应该和前臂成一条直线，不要上弯或者下弯，也不要侧弯。 拥有更多的显示空间确实会让你的工作更有效率。 购买优质座椅的必要性： 座椅是编程体验中一个主要的组成部分。 廉价的座椅很糟糕。 座椅是耐用品。 理想情况下你的显示屏不应该比灯光下的书本更亮。 设计时要把用户放在心上令人赏心悦目的产品和让人勉强容忍的产品之间的差别，就在于他们的细节有没有被做好（细节决定成败）。用户界面就代表了你的软件（前端的重要性）。用户界面须优先设计。在你草拟用户界面的时候，你必须置身于技术开发环境之外（不要被技术所束缚）。你应该努力不扯上下分页这玩意儿，因为你应该让用户在几个条目中就能找到他们所需要的东西，这高于一切。用户只会读取屏幕上足以让他们完成任务的、最少量的文字。你的团队对用户反馈的响应速度会为你的软件定下基调。即使第一版做的很差劲，也要坚持把它发布出去。 安全基础：保护用户数据尽量使用HTTPS协议，因为： HTTPS不再是奢侈品了。 HTTPS意味着没有人能够在互联网上监视你。 HTTPS现在变得更快了。 限制每个用户的登录尝试次数是安全领域的101（101空降师是美国陆军的一只空中突击部队，在诺曼底登陆战役中闻名）。安全的哈希算法应该能防止篡改，同时应该运行缓慢（减速暴力逆向破解的速度）。 加强代码测试，别让他太差劲软件开发人员应该与客户患难与共。同级之间的代码评审是你为提高代码质量所能做的最大的贡献。如果不找来真正的用户做可用性测试的话，你是无法知道你的程序能否正常工作的。 创建并管理社区，同时从中收益社区反馈的经验与教训： 90%的社区反馈都是垃圾。 别抵挡不住诱惑而误入歧途。 坦诚说出你不想做的事。 倾听社区的声音，但别被它们牵着鼻子走。 参与并支持你的社区。 游戏化的好处： 学习（应该）是有趣的。 游戏是学习的助手。 游戏促使人们齐心协力。 揭露营销伎俩，以及如何避免常见的9中营销伎俩： 用不恰当的比较来误导。 利用消费惯性（如把黑珍珠与珠宝翡翠放一起来抬高黑珍珠的价格）。 “免费”的诱惑。 假借社会行为准则（如利用社区或公益事业）。 故意允许拖延（如分期）。 利用禀赋效应。 利用人的“损失厌恶”。 制造不合理的期望。 利用对价的偏见。 游戏表面上看是免费的，但实际上他们要靠一小撮玩家通过花钱购买额外的东西来支撑（免费增值模式）。因此，玩家群体必须非常大，才足以维持这种游戏的业务模式。也因此，游戏的运营商通过会在互联网的广告空间里推广他们的游戏。（某迅游戏把这种营销方式发挥到淋漓精致）低价是一种营销推动力，它可以成倍的补偿价格降低的部分。 轻重缓急，了然于心幸福的方法： 把钱花在经历上，而不要花在物质上。 助人为乐。 很多次小的、愉快的购买实际上比一次巨额的购买更能有效地给你带来幸福。 少买保险（保险条款很容易不生效或者返利政策会让人不安）。 为将来买单。 三思而后行。 小心比较购物的陷阱。 随大流。 来也匆匆，去也匆匆（不是冲冲），到头来两手空空。 最后用文章最后抛出的一个问题，结束本章的内容： 对于程序员来说，最难的是要搞明白你夜以继日地拼命工作到底是为了什么？]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>程序人生</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《进化：从孤胆极客到高效团队》读书笔记]]></title>
    <url>%2F2019%2F05%2F12%2F%E3%80%8A%E8%BF%9B%E5%8C%96%EF%BC%9A%E4%BB%8E%E5%AD%A4%E8%83%86%E6%9E%81%E5%AE%A2%E5%88%B0%E9%AB%98%E6%95%88%E5%9B%A2%E9%98%9F%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[本书是Tock的创始人Brian Fitzpatrick和SVN开发者之一的Ben Collins-Sussman共同写的。下面是我记录的一些书中的重点： 天才程序神话人们总是缺乏安全感，就像程序员担心别人看到并评论自己未完成的工作，所以好多程序员在工作未完成的时候不会频繁地提交代码。人有一种本能：发现领导者和楷模，将他们偶像化，然后试图模仿他们。我们都需要崇拜英雄以激励自己，编程届也有自己的英雄。“技术名人”现象几乎演变成了神话。每个程序员都希望像林纳斯那么可以凭一己之力完成一个操作系统。但是一个人是不可能完成所有的事情，就比如林纳斯，他并没有完成Linux系统中所有代码的编写（他编写的是一个类Unix的概念内核原型，其实这已经很牛逼了），而要完成整个Linux系统，更多的是需要整个团队或者整个社区的努力。在内心深处，我们都希望成为天才。极客的最终幻想就是获得令人称赞的新创意。在山洞里闭关几周甚至数月，努力完美实现自己的创意，然后横空出世，令所有人惊叹不已。同行叹服于你的聪明才智，大众排队使用你的软件，名利随之而来。但是，这种天才神话往往是不可能发生的，所以你该醒醒了。天才神话一方面由于缺乏安全感而导致的，另一方面是担心自己的想法被别人知道（其实没必要，或许你以为独特的想法早就被别人想到了）。单独工作一定比多人合作更具有风险。编程领域极少出现独行侠，即便真有，他们也不是在真空中完成超人创举的。他们的惊世之作几乎都是灵感的火花和优秀团队创作出来的结果。因为软件开发是一项团队活动。优秀团队的三大基石：谦虚（Humility）、尊重（Respect）、信任（Trust）。以下简称HRT。HRT需要每个成员做的事：放下自我、批评与自我批评、快速失败和迭代、留出学习的时间、学会忍耐、接受改变。 打造团队文化团队文化不仅仅是团队成员完成工作、编写代码或彼此相处的方式，而且是成员共享的经验、价值观和目标。如果团队成员不重视团队文化，不仅难以培养很强大的团队认同感和对工作的集体荣誉感，而且新成员很容易给团队文化带来不好的影响。团队文化不是团队领导者负责维护的，而是每个成员参与的结果。人少时使用同步沟通（会议和电话等），人多时使用异步沟通（邮件、问题跟踪系统等）。高层同步方式：任务说明书、高效会议、设计文档。主持会议的5条准则： 只邀请必需人员参加； 草拟议程并在会议开始前尽早发出； 完成会议目标即可散会； 保持会议按议程进行； 尽量将会议安排在中断点附近（如午餐或下班的时间）。 日常讨论方式：邮件、在线聊天、面对面沟通。工作中的沟通：代码注释、署名、每次提交必有审阅、测试与发布流程。 群龙不可无首项目和船一样，如果没有人领航，项目团队就是一群只会等待事情发生而无所事事的极客而已。公司不应该强制员工的职业发展进入管理层。如果一个工程师能写出很好的代码，根本无意管理别人或领导团队，那么强制他担任管理或技术主管职位会使你失去一位优秀的工程师，换来一位差劲的经理（本书中的经理特指领导者）。领导者能做的最重要的事就是服务团队，就像管家照顾家人的健康和福利一样。服务型领导者为团队搭桥铺路，在需要时给出建议，而且依旧愿意从事具体工作。领导者不好的做法：雇佣软弱者、忽视表现不佳者、忽视人际关系、与所有人为友（要保持自己的权威）、放宽招人标准、把团队当孩子管（没必要什么都管）。领导者好的做法：放下自尊、成为禅意大师、成为团队催化剂、成员失败也没关系、成为老师或导师、设定清晰的目标、关注幸福度、要有自己的工作、寻找代替自己的人、给团队一方净土、保护团队、肯定团队的成就、激励团队。 应对有害的人不要将团队当作一个力图“驱除恶人”的精英兄弟会，而是要创造一种拒绝容忍特定负面行为的团队文化，也就是说需要去除的是行为而不是特定的人。常见的有害行为：不尊重他人的时间、自大、颐指气使、沟通幼稚或混乱、疑神疑鬼、完美主义。如何处理这些有害的行为：对完美主义者可以换个话题、对有意激怒你的人保持沉默、不要过于情绪化、在愤怒中寻找事实、以德报怨、适时放手、放眼未来。 组织操作的艺术理想的工作体验：完成本职工作后寻求更多的职责、承担风险且不惧失败、表现的像成年人一样、对不确定的东西提出疑问、及时与经理沟通。通常情况：经理不称职（比如经理害怕失败、不信赖员工、藏匿信息、遇到失败归结于员工身上、获得成功自己独享等），办公室政治家（建议尽量避开），管理不当的组织。组织操作的艺术：取得原谅比获取许可更容易、另辟蹊径、学会向上管理、帮助他人（或许不会立即带来好处，但有可能多年以后他会帮助你）、晋升到一个安全的职位、寻找有营销力的朋友。当有机会纠正错误的时候，身居高位的领导往往很乐意去做，繁忙的领导也是如此。如果的确无能为力，那就不要耗着，走为上策。但是，不是说如果现在的工作干得不开心就应该更新简历立马走人。相反，你的首要目标应当是作出所需的改变，使自己开心，完成目标。 用户也是人要创造优秀的产品，需要积极地与用户合作。如果创造更好的产品： 市场营销：了解人们对软件的看法；着决定了他们会不会愿意尝试。 产品设计：如果软件做不到容易尝试、速度快、又好而且用户面广，用户就会流失。 客户服务：主动与用户建立长期的良好关系能影响软件的演化和用户保持率。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微任务与宏任务]]></title>
    <url>%2F2019%2F04%2F27%2F%E5%BE%AE%E4%BB%BB%E5%8A%A1%E4%B8%8E%E5%AE%8F%E4%BB%BB%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[众所周知，JavaScript是基于事件循环而运行的，微任务与宏任务是事件循环中重要概念。自node火起来后，这个知识点就成了面试官压轴大题，所以我们必须要会。 JavaScript的异步最开始的时候是基于一个个的回调函数，而事件循环中任务，说白了也就是一个个的函数，毕竟函数是JavaScript中的一等公民。那么什么是微任务，什么又是宏任务呢？其实是通过执行的时机来区分的： 微任务：在本次任务执行完后执行。宏任务：在下一个任务循环的时候执行。 这里有一张经典的图片，供大家参考： 每次事件的循环的执行都是以宏任务开始的。如果本次宏任务执行完毕了，那么就会检索是否有微任务，如果有，那么就去执行微任务，如果微任务执行完或者没有微任务的话那么就会进入下次事件循环。 常见的宏任务：setTimeout、setInterval、setImmediate（Node特有）、requestAnimationFrame（浏览器特有）。常见的宏任务：Promise中的then/catch/finally方法、process.nextTick（Node特有）。 这里需要注意一点是Promise的构造方法在new的时候会立即执行。下面来看一个老掉牙的经典面试题吧：1234567891011121314151617181920212223242526272829303132333435363738console.log('1');setTimeout(function() &#123; console.log('2'); process.nextTick(function() &#123; console.log('3'); &#125;) new Promise(function(resolve) &#123; console.log('4'); resolve(); &#125;).then(function() &#123; console.log('5') &#125;)&#125;);process.nextTick(function() &#123; console.log('6');&#125;);new Promise(function(resolve) &#123; console.log('7'); resolve();&#125;).then(function() &#123; console.log('8')&#125;);setTimeout(function() &#123; console.log('9'); process.nextTick(function() &#123; console.log('10'); &#125;) new Promise(function(resolve) &#123; console.log('11'); resolve(); &#125;).then(function() &#123; console.log('12') &#125;)&#125;) 分别打印：1 7 6 8 2 4 3 5 9 11 10 12。如果和你的预期是一样的说明你已经掌握了，就没必要看下面的分解步骤了。 首先打印1。第3行遇到setTimeout加入到宏任务队列中，下次处理。第16行，遇到微任务process.nextTick，加入到微任务的队列中。第20行new Promise执行构造方法打印7，将then放在微任务队列中。第20行发现setTimeout，放入宏任务队列中。 本次任务执行完后，检测微任务，发现有2个，一个是第16行的process.nextTick，一个是23行的then，分别执行，打印6和8。 执行下一个宏任务，也就是第3行的setTimeout，分别打印2和4，发现有2个微任务，分别打印3和5。 执行下一个宏任务，也就是第27行的setTimeout，分别打印9和11，发现有2个微任务，分别打印10和12。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>事件循环</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[非零环绕规则]]></title>
    <url>%2F2019%2F04%2F27%2F%E9%9D%9E%E9%9B%B6%E7%8E%AF%E7%BB%95%E8%A7%84%E5%88%99%2F</url>
    <content type="text"><![CDATA[非零环绕规则是图形学中判断某个区域是在所属区域外面还是内部的一种规则。 简单说一下就是这个样子：对于路径中的任意给定区域，从该区域内部画一条足够长的线段，使此线段的终点完全露在路径范围之外。然后将计数器初始化为0，每当这条线段与路径上的直线或曲线相交时，就改变计数器的值。如果与路径顺时针部分相交的时候，则加1；如果与路径的逆时针部分相交的时候，则减1。如果最终值不是0，那么说明区域在路径的里面。 如上图，一条闭合的路径，围绕成了3个区域，也就是图中的A、B、C（图略丑，凑合着看吧）。A区域向外引一条线段（绿色的），可以看到与路径的顺时针相交，所以计数器加1，变成了1，而再外面一些是不会相交了，由于1不是0，所以A在路径里面。同理，B区域引一条线段，我们可以看到和逆时针相交，所以减1，也就是-1，也不会再与路径相交了，由于-1不是0，所以B也在路径的内部。对于C我们引入一条线段，它2次都与顺时针相交，所以计数为2，也就在区域的内部了。 明白了基本的原理我们看一个代码相关的例子吧。现有HTML：1&lt;canvas id="canvas"&gt;不支持canvas&lt;/canvas&gt; 如果支持HTML5的canvas的时候会创建一个默认大小为300px*150px的canvas画板；如果不支持的时候会把canvas当成一个div元素来处理，那么就会显示里面的文字了。 然后我们使用JS来绘制图案：12345678var canvas = document.getElementById("canvas");var context = canvas.getContext("2d");context.fillStyle = "red";context.beginPath();context.arc(150, 75, 50, 0, Math.PI * 2, false);context.arc(150, 75, 25, 0, Math.PI * 2, true);context.fill(); 由上我们画了2个弧线，顶点都是(150,75)的位置（其实就是canvas的中心），然后半径一个是50，一个是25，都是从0到2π（弧度2π也就是360°），所以我们画的是2个圆形（弧线是从右边开始画弧的）。最后一个参数有意思，如果为true的时候是逆时针绘制，如果是false则是顺时针绘制（默认是false），那么上述路径中，内圆内部向外引一条射线，那么与内圆交叉的地方是逆时针，那么减1，而与外圆相交的地方是顺时针，所以加1，所以最终的结果是0，也就是内圆内部其实是路径的外面，所以绘制出来的结果如下： 如果我们把上述画弧的最后一个参数都去掉的话（使用默认值false），那么效果是怎么样子呢？当然是内圆内部也在路径的内部了（有点绕），如下：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>非零环绕规则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS7层层叠顺序]]></title>
    <url>%2F2019%2F04%2F25%2FCSS7%E5%B1%82%E5%B1%82%E5%8F%A0%E9%A1%BA%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[层叠顺序如下： 更具体的可以参考张鑫旭的这篇文章。]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>层叠顺序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试官：考你几个简单的事件问题吧]]></title>
    <url>%2F2019%2F04%2F21%2F%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A%E8%80%83%E4%BD%A0%E5%87%A0%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E4%BA%8B%E4%BB%B6%E9%97%AE%E9%A2%98%E5%90%A7%2F</url>
    <content type="text"><![CDATA[面试官：考你几个简单的事件问题吧。几小时后的你：虽然面试官考的很简单，但是就是没有答上来。 事件处理是JavaScript中非常重要的概念，我们使用的客户端软件往往都是事件驱动的，所以面试官特别喜欢问一些事件相关的知识，这里记录几个常见的问题，供大家学习。 事件流的三个阶段：事件捕获阶段、目标阶段和事件冒泡阶段（这个问题大多数同学都知道，很容易被问懵）。 事件处理函数（事件侦听器）：响应的某个事件函数。 添加事件有几种方式（以click事件为例）？ 在HTML中添加onclick属性，值使用JS的字符串来表示要执行的事件。 123456&lt;input type="button" id="btn" value="按钮" onclick="handleClick()"&gt;&lt;script type="text/javascript"&gt; function handleClick()&#123; console.log("按钮被点击了"); &#125;&lt;/script&gt; 给DOM元素添加onclick方法，如下 1234var btn = document.getElementById("btn");btn.onclick = function ()&#123; console.log("按钮被点击了");&#125;; DOM元素使用addEventListener（IE使用attachEvent）来添加方法，如下 1234var btn = document.getElementById("btn");btn.addEventListener("click",function ()&#123; console.log("按钮被点击了");&#125;); 上述这种onclick和addEventListener两种添加事件的方式有什么不同？ onclick是DOM0级事件处理方式，而addEventListener是DOM2级事件处理方式，所以兼容性onclick会更好一些（虽然现在addEventListener也不会有什么问题）。 addEventListener可以添加多个方法，而onclick只能添加一个。 addEventListener可以添加第三个参数，表示是捕获还是冒泡阶段调用，如果为true的时候表示捕获阶段调用，如果是false的话表示冒泡阶段调用，默认是冒泡阶段调用（undefined相当于是false）。 12345678910btn.addEventListener("click",function ()&#123; console.log("按钮被点击了");&#125;,true);document.body.addEventListener("click",function ()&#123; console.log("body被点击了");&#125;,true);// 点击按钮的时候会先打印"body被点击了" 后 打印 "按钮被点击了"// 因为第三个参数是true的时候表示捕获阶段调用// 如果第三个参数都是false的时候 那么先打印 "按钮被点击了" 后打印 "body被点击了"// 如果一个是false一个是true那么先打印为true的 因为捕获阶段先于冒泡阶段 addEventListener可以使用removeEventListener来删除事件处理程序，而onclick最多只有一个事件处理程序，所以只要btn.onclick = null;就可以了。 addEventListener与attachEvent有什么不同？ addEventListener适用于正常的W3C浏览器，而attachEvent适用于IE浏览器（注：Edge都不支持这玩意）。 attachEvent第一个参数，需要带”on”。比如添加click事件那么attachEvent的第一个参数是”onclick”。 addEventListener中的this指向DOM元素，而attachEvent中的this指向window。 attachEvent只支持冒泡不支持捕获，所以也就没有第三个参数。 attachEvent如果添加多个事件处理程序那么先执行后添加的后执行先添加的，这与addEventListener恰好相反（IE9和IE10修改了执行顺序和addEventListener一样了，先添加的先执行）。 如何获取事件对象event？通常情况下事件处理程序的第一个参数就是event对象，如下：123btn.addEventListener("click",function (event)&#123; // event 就是事件对象 通常的习惯 也可以命名为e&#125;); 但是有一种情况下例外，就是IE的DOM0级事件onclick的情况下，使用的是window.event来获取（没错attachEvent也是通过事件处理函数的第一个参数来获取）：1234btn.onclick = function (event)&#123; event = event || window.event;// 兼容性处理 console.log(event);&#125; 如何来阻止默认行为？普通浏览器使用event.preventDefault()来阻止默认行为，IE使用event.retureValue = false;（注意：并不是函数return一个false）来阻止：12345678btn.onclick = function (event)&#123; event = event || window.event;// 兼容性处理 if(event.preventDefault)&#123;// 阻止默认行为 event.preventDefault(); &#125; else &#123; event.retureValue = false;// IE &#125;&#125; 如何来阻止事件冒泡？普通浏览器使用event.stopPropagation();来阻止事件冒泡，IE使用event.cancelBubble = true;：12345678btn.onclick = function (event)&#123; event = event || window.event;// 兼容性处理 if(event.stopPropagation)&#123;// 阻止事件冒泡 event.stopPropagation(); &#125; else &#123; event.cancelBubble = true;// IE &#125;&#125; 那些标签支持load事件？body（或者window对象），img，script（IE9+），link（IE和Opera支持）。 点击一下鼠标前后会调用那些事件？mousedown &gt; mouseup &gt; click。 双击鼠标前后会调用那些事件？mousedown &gt; mouseup &gt; click &gt; mousedown &gt; mouseup &gt; click &gt; dbclick。 点击一下键盘前后会调用那些事件？keydown &gt; keypress &gt; keyup（注意这里与click的区别）。 按下键盘一直不放前后会调用那些事件？keydown &gt; keypress &gt; keydown &gt; keypress … 移动端触摸一下屏幕前后会调用那些事件？touchstart &gt; touchend &gt; mouseover &gt; mousemove（触发一次） &gt; mousedown &gt; mouseup &gt; click。 事件处理做过什么优化？ 使用事件委托，如表格中删除某一行可以把事件添加到表格上而不是td标签，然后判断那一个元素出发的，然后对特定元素做处理，这样既可以减少事件监听的数量有可以不用关系新增元素的时间。 移除HTML的时候，先把绑定的事件删除。 如果用户在页面上填写了一些数据现在要关闭页签，我想在用户关闭的时候提醒他一下该怎么做？监听window对象上的beforeunload事件就可以了，可以设置event.returnValue的值等于一个提示语，也有浏览器是根据返回的字符串来提示的：12345678910111213141516function addEvent(element,type,handler)&#123;//通用事件添加函数 if (element.addEventListener) &#123; element.addEventListener(type,handler); &#125; else if (element.attachEvent) &#123; element.attachEvent("on" + type,handler); &#125; else &#123; element["on" + type] = handler; &#125;&#125;addEvent(window,"beforeunload",function (event)&#123; event = event || window.event; var msg = "官人，你先别走啊，你填的东西还没有保存呢！请不要弃我而去啊..."; event.returnValue = msg;// IE的处理 return msg;//普通浏览器的处理&#125;); 这里需要注意一点虽然我们给了特定的字符串并不是所有浏览器都会显示这个字符串的，Chrome就会给定特定的提示语而不是使用我们给定的字符串，但是只有给定字符串不为空（隐式转化为true）它才会给出提示。 下列代码依次打印的是什么？12345678910111213141516171819// 这里btn还是上面的button元素。btn.addEventListener("click",function ()&#123; console.log("冒泡事件1")&#125;,false);btn.addEventListener("click",function ()&#123; console.log("冒泡事件2")&#125;,false);document.body.addEventListener("click",function ()&#123; console.log("document.body冒泡事件")&#125;,false);btn.addEventListener("click",function ()&#123; console.log("捕获事件1")&#125;,true);btn.addEventListener("click",function ()&#123; console.log("捕获事件2")&#125;,true);document.body.addEventListener("click",function ()&#123; console.log("document.body捕获事件")&#125;,true); 执行的结果是： document.body捕获事件冒泡事件1冒泡事件2捕获事件1捕获事件2document.body冒泡事件 事件是先捕获后冒泡的，所以第一个和最后一个是没有问题的。中间4个事件的执行，都是处于目标阶段，目标阶段会按照事件的添加顺序来执行，而不会管你是否是捕获还是冒泡。 如何让一个事件先冒泡后捕获？浏览器都是先捕获后冒泡的（如果支持捕获的时候），并不支持先冒泡后捕获，我们可以改造一下捕获的函数，让他在冒泡结束后再执行，就可以达到类似的效果。如上面最后一个document.body的事件可以像下面这样改造一下，那么document.body捕获事件将会在最后打印。12345document.body.addEventListener("click",function ()&#123; setTimeout(() =&gt; &#123; console.log("document.body捕获事件") &#125;, 0);&#125;,true);]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>事件处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP文件缓存判断流程]]></title>
    <url>%2F2019%2F04%2F20%2FHTTP%E6%96%87%E4%BB%B6%E7%BC%93%E5%AD%98%E5%88%A4%E6%96%AD%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[缓存判断流程： 如果Cache-Control（或者Expires，Expires绝对时间，优先级比Cache-Control低）未过期，那么使用缓存，否则按照下一条来判断。 如果有Etag，则会向服务器发送Etag和If-None-Match，由浏览器来判断是200还是304。如果没有Etag那么按照下一条来判断。 浏览器判断上次文件响应头中是否有Last-Modified信息，有则连同If-Modified-Since一起发送到服务器，由服务器来判断200还是304。 如果以上都没有使用，那么浏览器请求一次服务器，返回200。]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《现代前端技术解析》读书笔记]]></title>
    <url>%2F2019%2F04%2F20%2F%E3%80%8A%E7%8E%B0%E4%BB%A3%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF%E8%A7%A3%E6%9E%90%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[这本书并没有讲太多的深层次的技术，讲的都是一些原理与思路，非常适合想要从宏观上了解前端的读者。本笔记按照里面的章节记录一些书中有意思的部分。 Web前端技术基础前端开发模式的演变：静态黄页、服务器组装动态网页数据、后端为主的MVC、前后端分离、纯前端MV*为主与中间层直出、前端Virtual DOM与MNV*前后端同构。 浏览器的组成部分：用户界面、网络、JavaScript引擎、渲染引擎、UI后端、JavaScript解释器和持久化数据存储。 渲染引擎工作流程：解析HTML构建DOM树、构建渲染树、渲染树布局阶段、绘制渲染树。 页面生成后，如果页面元素位置发生变化，就要从布局阶段开始重新渲染，这个过程叫做重排。如果页面元素只是显示样式改变而布局不变，那么页面内容改变将从绘制阶段开始，也成为页面的重绘。重排通常会导致页面元素几何大小位置发生变化且伴随着重新渲染的巨大代价，因为我们要尽量减少重排。 CSS权重：!important &gt; 内联样式 &gt; id选择器 &gt; 类选择器 &gt; 标签选择器 &gt; 继承的样式 浏览器所支持的缓存方式：HTTP文件缓存、LocalStorage、SessionStorage、indexDB、Web SQL、Cookie、cacheStorage、Application Cache。 Chrome浏览器HTTP缓存资源位置：DevTools &gt; Application &gt; Frames HTTP文件缓存判断流程，这一部分比较重要，单独成章，请看这里。 sessionStorage关闭浏览器会自动清空。 Cookie一般会通过HTTP请求发送到服务端，通常认为醉倒长度限制是4KB，可以分为Session Cookie和持久型Cookie。其中Session Cookie保存在内存中，浏览器关闭会消失；持久型Cookie保存在硬盘中。 调试node:12npm install -g node-inspectornode-debugger index.js 然后使用node-inspector命令会给出一个url，浏览器访问这个url就可以调试了。 前端与协议通常一个完整的HTTP报文由头部、空行、正文三部分组成。空行用于区分报文头部和报文正文，由一个回车符和一个换行符组成。 HTTP1.1标准发布与1999年，相对于1.0增加了协议扩展切换、缓存、部分文件传输优化、长连接、消息传递、host头域、错误提示等一些重要的增强特性。 HTTP1.1长连接机制是通过请求头中的keep-alive头信息来控制的。默认是包含此信息的。1.0如果添加的话如果服务器支持的情况下会返回一个keep-alive表示文件请求可以复用之前的请求。 协议扩展切换指的是HTTP1.1协议支持在请求头信息中添加Upgrade头并让客户端通过头部标识令服务器知道它能够支持其他备用通讯协议的一种机制。如WebSocket连接时浏览器会在头信息中添加Connection:Upgrade和Upgrade:websocket告诉浏览器，后面要进行协议切换为WebSocket协议，如果浏览器支持的话则在响应头中返回上面2个头信息，并返回101的响应码。 部分文件传输优化说的是HTTP1.1不仅可以传输文本，也可以传输二进制数据，如FormData。 HTTP2.0的特性： 完全采用二进制格式来传输数据。 使用TCP多路复用的方式来降低网络请求连接时建立与关闭的开销。 支持传输流的优先级和流量控制机制，所以不需要再把CSS放在HTML顶部，JavaScript放在HTML底部，HTTP2.0自动就会做这些事情。 支持服务端推送。 强制使用SSL协议，所以肯定是HTTPS协议。 常见的网络攻击手段：XSS、SQL注入、CSRF（cross-site Request Forgery,跨站点请求伪造）。 XSS可以通过转义HTML标签来解决，SQL注入可以使用预处理来解决，CSRF可以通过添加Token来解决（相对的）。 DNS劫持，攻击者劫持了DNS，使得域名转化为IP的过程，指向了其他的IP。HTTP劫持，读取或者修改HTTP报文中的内容，常用的处理措施就是使用HTTPS请求。 HTTPS协议是通过加入了SSL层来加密HTTP数据进行安全传输的HTTP协议，默认端口是443。 服务端主动找客户端的方式：WebSocket、轮询、长轮询、DDP（普及程度不高）、HTTP流。 前端三层结构与应用页面使用table标签会比较慢，因为table会等表格内全部内容都解析完成后进行一次性渲染。 ES7常用的三种特性：幂指数操作符（2**3 === 8），Array.prototype.includes，async/await。 前端统一CSS样式的方式：reset（清楚浏览器的默认样式）、normalize（使用某一种默认样式）、neat（两者结合，需要根据网页设计特点来）。 前端实现动画的五种方式：JavaScript操作DOM实现，SVG动画，CSS transition、CSS animation、Canvas。 响应式设计的2种方法： 前端或者后端判断userAgent来跳转不同的页面来完成不同设备浏览器的适配（常见的移动端以m.开头的域名）。 使用媒体查询，自动改变页面布局。 常用的rem初始值定义方法： 1rem = 屏幕宽度 * 屏幕分辨率 / 10也就是1rem想到于屏幕宽度的10%，所有尺寸相当于使用百分比来布局的。 1rem = 屏幕宽度 / 320 * 10也就是1rem想到于320px屏幕上的10像素。 本章其他内容主要为HTML、CSS、JS的一些基础知识以及ES6的一些内容，这里就不再列出来了。 前端项目与技术实践前端通用规范：三层架构分离（HTML/CSS/JS）、缩进（通常一个tab四个空格）、内容编码（&lt;meta charset=&quot;UTF-8&quot;&gt;）、标签属性等使用小写、代码每行不超过120个（或80个）字符、多写注释、行尾去掉多于的空格与符号。 for-in循环里面要尽量含有hasOwnProperty防止访问原型中的属性或方法。 常用的模块化方法有：AMD（requireJS）、CMD（seaJS）、CommonJS（node规范）、import/export等。 自动化构建常用流程：读取入口文件、分析模块引用、按照引用加载模块、模块文件编译处理、模块文件合并、文件优化处理、写入生成目录。 简单上报用户点击位置的代码：123$(document).on("click","body",function (e)&#123; report(e.pageX,e.pageY);&#125;) 作为前端的开发者，学习的方式有很多，比如看别人的技术博客，研究最新的技术方向、阅读开源代码、挺技术分享会、看书等。 一切技术最终的目的都是为产品实现服务的，切记勿过分追求技术，建议大家看一两本关于产品经理方向的书籍。 到此，我们记录了一些书中重点的部分，此外还有很多一部分内容讲的是MVVM的思想、以及前端跨栈开发、一些技术的实践、对前端未来的一些展望等，由于内容比较多就不展开详细说了，感兴趣的小伙伴可以去看看书。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>前端技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bind、call、apply的实现]]></title>
    <url>%2F2019%2F04%2F18%2Fbind%E3%80%81call%E3%80%81apply%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[bind、call、apply是JavaScript中Function.prototype非常重要的三个方法，他们的作用是改变this的指向。三者的区别是： bind返回一个函数，该函数改变了this的指向。call直接调用函数，也可以传递参数用逗号隔开。apply直接调用函数，也可以传递参数使用数组传递给第二个参数。 我们现在详细解读一下各个函数的实现方式。 bind的实现bind的基本用法： 函数调用bind，返回一个新的函数。 bind方法的第一个参数是宿主对象，也就是执行的this。 bind返回函数执行时候的参数是bind方法第二个至多个参数与调用时参数的合集。 bind简单实现：123456789101112Function.prototype.bind = function (context) &#123; var self = this;// 这个this其实是真正的函数 // 获取第二至多个参数 var args = Array.prototype.slice.call(arguments, 1); // 返回一个函数 该函数是真正执行时的函数 return function () &#123; // 获取真正执行时传进来的函数 var bindArgs = Array.prototype.slice.call(arguments); // 合并参数 并且调用函数 return self.apply(context, args.concat(bindArgs)); &#125;&#125; 这个简单的bind已经解决了上面的三个基本用法了，其实bind还有2个附加的特性： 如果上面self不是函数（防止非函数的原型指向Function.prototype），那么会报错。 从改变this的指向来看，new的优先级大于bind。 功能更强大的bind实现：123456789101112131415161718192021222324Function.prototype.bind = function (context) &#123; var self = this; if (typeof self !== "function") &#123;// 如果self不是函数则报错 throw new Error("Function.prototype.bind - what is trying to be bound is not callable"); &#125; var args = Array.prototype.slice.call(arguments, 1); // 定义一个中间函数 让返回的函数继承它 var FN = function () &#123;&#125;; var returnFn = function () &#123; var bindArgs = Array.prototype.slice.call(arguments); // 重点 如果返回函数的this是FN 说明是new出来的 this就是new的对象 否则是context return self.apply(this instanceof FN ? this : context, args.concat(bindArgs)); &#125; // FN的原型指向函数的原型 FN.prototype = self.prototype; // 返回的函数继承FN returnFn.prototype = new FN(); return returnFn;&#125; call的实现call的基本用法： 函数调用call，函数会执行，并且this指向了第一个函数。 call方法的第一个参数是null或者undefined的时候this会绑定在全局对象上。 call方法第二个至多个参数会传给执行的方法。 call方法简单实现：12345678910111213141516171819Function.prototype.call = function (context) &#123; // 如果为空 则绑定在全局函数 var context = context || window; // 使用context.fn() 来调用函数 来模拟fn绑定在context上 context.fn = this; var args = []; for(var i = 1, len = arguments.length; i &lt; len; i++) &#123; args.push('arguments[' + i + ']'); &#125; // 这里比较尴尬 因为context.fn调用的时候 无法把不定长的arguments 一个一个地传进去 // 所以就使用eval方法了 当然可以用apply但是稍后我们也要实现它 所以就不能用了 var result = eval('context.fn(' + args +')'); // 删除添加的方法（毁尸灭迹） delete context.fn; return result;&#125; apply的实现apply的基本用法： 函数调用apply，函数会执行，并且this指向了第一个函数。 apply方法的第一个参数是null或者undefined的时候this会绑定在全局对象上。 apply方法第二个参数是一个数组，相当于函数执行时的参数。 apply方法简单实现：12345678910111213141516171819Function.prototype.apply = function (context, arr) &#123; var context = context || window; context.fn = this; var result; if (!arr) &#123; result = context.fn(); &#125; else &#123; var args = []; for (var i = 0, len = arr.length; i &lt; len; i++) &#123; args.push('arr[' + i + ']'); &#125; result = eval('context.fn(' + args + ')') &#125; delete context.fn; return result;&#125;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>bind</tag>
        <tag>call</tag>
        <tag>apply</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[generator处理异步操作]]></title>
    <url>%2F2019%2F04%2F14%2Fgenerator%E5%A4%84%E7%90%86%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[generator是ES6新的语法，我们先简单的回顾一下他的使用： generator基本用法123456789101112function * genFn() &#123; yield 'aaa'; yield 'bbb'; return 'ccc';&#125;var gen = genFn();gen.next();// &#123;value: "aaa", done: false&#125;gen.next();// &#123;value: "bbb", done: false&#125;gen.next();// &#123;value: "ccc", done: true&#125;gen.next();// &#123;value: undefined, done: true&#125;gen.next();// &#123;value: undefined, done: true&#125; generator函数是在function和函数名之间添加*来定义的。generator函数调用后并没有真正的执行，当调用返回对象的next方法会执行并返回generator函数定义处的yield（或return）前面的值，从而使得执行与定义分离。 generator对象的next方法也可以传参： 123456789101112131415161718function * genFn(arg) &#123; console.log("arg=" + arg) var a = yield 'aaa'; console.log("a=" + a); var b = yield 'bbb'; console.log("b=" + b); return 'ccc';&#125;var gen = genFn("123");// 将arg的值赋值为“123” 但是并没有执行var ga = gen.next("a");// 执行 打印"arg=123" 因为并没有yield所以相当于“a”的值没有赋值给任何变量console.log(ga);// &#123;value: "aaa", done: false&#125;var gb = gen.next("b");// 执行 并把"b" 传给变量a 打印"a=b" console.log(gb);// &#123;value: "bbb", done: false&#125;var gc = gen.next("c");// 执行 把"c"的值赋值给b 打印"b=c"console.log(gc);// &#123;value: "ccc", done: true&#125;gen.next();// &#123;value: undefined, done: true&#125;gen.next();// &#123;value: undefined, done: true&#125; generator简单异步处理现在使用有一个异步的fetch请求，打印出它返回的结果，我们可以这么写generator：123456789101112function* asyncGenFn() &#123; var result = yield fetch("https://api.github.com/emojis"); console.log(result);&#125;var gen = asyncGenFn();// 一定要注意这里没有执行var result = gen.next();// &#123;value: Promise, done: false&#125;// 此时的result.value就是asyncGenFn中的fetch返回的Promise 那么此时就可以这么处理了result.value.then(data=&gt;data.json())// 将数据转化为JSON格式 .then((data)=&gt;&#123; gen.next(data);// 把data再传回asyncGenFn让他自己打印 &#125;); 上面我们已经把一个异步操作用generator处理了，我们现在处理2个异步操作，再加一个fetch请求发送后的1秒后打印字符串的一个异步操作。123456789101112131415161718192021222324252627var promise = new Promise(function(resolve, reject) &#123; setTimeout(function ()&#123; resolve("Hello World");// 1秒后打印Hello World &#125;,1000);&#125;);function* asyncGenFn() &#123; var result1 = yield fetch("https://api.github.com/emojis"); console.log(result1); var result2 = yield promise; console.log("异步数据是：" + result2);&#125;var gen = asyncGenFn();// 一定要注意这里没有执行var result1 = gen.next();// &#123;value: Promise, done: false// 此时的result.value就是asyncGenFn中的fetch返回的Promise 那么此时就可以这么处理了result1.value.then(data=&gt;data.json())// 将数据转化为JSON格式 .then((data)=&gt;&#123; var result2 = gen.next(data);// 把data再传回asyncGenFn让他自己打印 // 调用这里的前半部分和之前的是一样的 现在开始处理第二个yield // 此时的resulet2的值是 &#123;value: Promise, done: false&#125; // 其中result2.value就是asyncGenFn中的promise 那么此时你可以 result2.value.then((val)=&gt;&#123;// 这个val就是"Hello World" gen.next(val);// 把"Hello World"传回打印 "异步数据是：Hello World" &#125;); &#125;); 通过2次的异步请求我们貌似发现了点处理规律，上面对generator的处理基本上都是大同小异，唯一一点区别就是result1.value.then调用的时候先转换了一下数据。其实转换数据这一个步骤也是一个Promise那我们就可以把他当做异步来处理咯，也就是可以放在asyncGenFn函数内部来处理，请看这里：1234567891011121314151617function* asyncGenFn() &#123; var result1 = yield fetch("https://api.github.com/emojis"); result1 = yield result1.json();// 异步就yield一下 console.log(result1); var result2 = yield promise;//promise还是上面的promise console.log("异步数据是：" + result2);&#125;var gen = asyncGenFn();// 一定要注意这里没有执行gen.next().value.then((data)=&gt;&#123;// fetch gen.next(data).value.then((val)=&gt;&#123;// 转换为json gen.next(val).value.then((val)=&gt;&#123;// 异步promise gen.next(val); &#125;); &#125;);&#125;); 这下有没有豁然开朗，异步操作的执行其实是一个套路，就是递归调用gen.next().value.then()就可以了。由上可知，异步的generator执行时如果遇到yield那么就去调用gen.next().value.then()去处理该Promise，后面这个处理的过程是很机械地，我们是否可以把处理Promise这个过程封装一下，然后将注意力完全放在generator上呢，假如我们把这个封装好的东西叫他执行器，那样我们就彻底不需要关注执行器怎么实现了，只需要关注generator然后用执行器去执行它。此时你貌似懂了点什么，但是你还会问如果不是Promise的异步操作呢？我们先不考虑这种情况，这里假设你很聪明，传的所有的异步操作都是Promise。某大神说：“过早的优化是万恶之源。”。现在我们就简单的实现一下这个执行器吧： 123456789101112131415function actuator(gen)&#123;// 接收一个 generator 函数 var g = gen();// 并没有执行 function next(data)&#123; var result = g.next(data);// 调用next方法 if (result.done) return result.value;// 如果结束则返回值 result.value.then(function(data)&#123;// 上面的套路 next(data);// 递归调用 &#125;); &#125; next();&#125;actuator(asyncGenFn); // 用执行器去执行 结果一下 generator异步处理绕不开的一个库co我们用了很少的几行代码写了一个执行器，其实这上面的actuator函数是对大神TJ Holowaychuk所写的co库的拙劣模仿，现在我们可以直接引用co库来实现我们的异步操作：123var co = require('co');co(asyncGenFn); // 就这么简单 处理generator的异步就这么简单，直接用co库包一层就会执行。之前我们还留了一个问题，如果yield后面的不是Promise那该怎么办？其实也好办，只要把它转换为Promise就可以了，co也是这么做的。另外我们这里假设都是直接成功的，失败的情况下并没有考虑，co已经把失败的情况也处理了。那它在我们的actuator函数的基础上做了那些操作呢？请看co源码，github仓库在这里。 async函数处理异步async函数处理异步也很简单，如上面的例子我们可以这么写：12345678910async function asyncFn() &#123;// 使用async关键字的函数 var result1 = await fetch("https://api.github.com/emojis"); result1 = await result1.json();// 异步就await一下 await关键字只能用于async函数 console.log(result1); var result2 = await promise;//promise还是上面的promise console.log("异步数据是：" + result2);&#125;asyncFn();// 执行async函数 不知道你有没有发现async函数和generator函数处理异步的代码很相似，无非就是把*换成async并且挪了一个位置（不挪位置编译器还以为async是你的函数名呢），然后把里面的yeild换成了await。其实async函就是generator和co的语法糖：12345678910111213async function fn(args) &#123; // ,,, 里面可能用到了await&#125;// 就相当于function fn(args) &#123; return co(function* () &#123; // ... 里面用到了yeild &#125;);&#125;// 所以异步函数fn的执行fn()相当于用执行器co来执行generator]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>generator</tag>
        <tag>异步</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript中的正则表达式]]></title>
    <url>%2F2019%2F04%2F13%2FJavaScript%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[正则表达式（Regular Expression）描述了一种字符串匹配的模式，可以用来检查一个字符串是否含有某种子串，将匹配的子串做替换或者从某个串中取出符合某个条件的子串等。 创建正则对象 语法模拟 1var regExp = /\d/gi; new创建 1var regExp = new RegExp("\\d","gi"); 两者的区别：如果使用new来创建那么需要对正则表达式进行转义如\d需要转义为\\d，\\需要转义为\\\\。 匹配标示 匹配标示 含义 g 全局匹配 i 忽略大小写 m 多行搜索 正则表达式的使用JavaScript中正则表达式的使用涉及2个类型，一个就是上面的RegExp，还有一个就是我们常用的String。RegExp对象正则处理常用的方法： 方法 描述 使用 test 匹配参数是否出现在字符串中 regExp.test(str); exec 返回匹配模式的字符串 regExp.exec(str); String对象正则处理常用的方法： 方法 描述 使用 search 匹配符合匹配规则的字符串出现的位置 str.search(regExp);// 没匹配到返回-1 match 返回匹配模式的字符串（返回数组） str.match(regExp);// 没匹配到返回null replace 使用指定的内容替换匹配到的字符串 str.replace(regExp,”新的字符串或函数”); split 使用匹配到的字符串进行分割字符串（返回数组） str.split(regExp);// 没匹配到返回整个字符串的数组 此外regExp对象还有几个不太常用的属性：123456var regExp = /\d/gi;console.log(regExp.global);// 是否全局变量 如果有标识符g 那么返回true 这里打印trueconsole.log(regExp.ignoreCase);// 是否忽略大小写 如果有标识符i 那么返回true 这里打印trueconsole.log(regExp.multiline);// 是否多行 如果有标识符m 那么返回true 这里打印falseconsole.log(regExp.source);// 匹配规则 这里打印\dconsole.log(regExp.lastIndex);// 开始搜索下一个匹配项的位置 这里打印0 子表达式与反向引用这里有几个比较重要的概念： 子表达式：在正则匹配中，使用一对括号括起来的内容就是子表达式。捕获：在正则匹配中，子表达式匹配到的内容会被系统捕获到系统的缓冲区中。反向引用：当捕获以后，可以在匹配模式中使用\n（n表示数字，从1开始），来引用系统中第几号缓冲区的内容。 我们看个例子，假设我们要匹配两个相同单词（这里的单词其实是指多个字母）中间是三个数字的内容，如a123a、abc666abc这种的：1234var str = "java123javabbb1232bccccc322deee666e";var regExp = /(\w+)\d&#123;3&#125;\1/gi;// 捕获多个字母 中间是3个数字 然后后面的内容与前面的相同var result = str.match(regExp);console.log(result);// ["java123java", "e666e"] 是不是有点明白了，不明白我们再看一个简单的例子，查找如1221、6886这样的ABBA形的数字：1234var str = "12213456886";var regExp = /(\d)(\d)\2\1/gi;// 捕获2个数字 然后先是第二个数字 后是第一个数字var result = str.match(regExp);console.log(result);// ["1221", "6886"] 通常情况下，后面内容和前面内容一致的情况下，就使用到子表达式、捕获、反向引用的概念了。 上面的例子也可以使用RegExp对象的exec方法：123456789var str = "12213456886";var regExp = /(\d)(\d)\2\1/gi;var result;while(result = regExp.exec(str))&#123; console.log(result); // 分别打印： // ["1221", "1", "2", index: 0, input: "12213456886", groups: undefined] // ["6886", "6", "8", index: 7, input: "12213456886", groups: undefined]&#125; 可见，exec方法需要循环打印，打印的结果也更加全面。如果要获取匹配到的内容可以获取下标为0的元素。 限定符 限定符可以指定正则表达式的一个给定内容必须出现多少次才能满足匹配。 如上面例子中var regExp = /(\w+)\d{3}\1/gi;其中{3}就是限定符，限制必须出现3次。更多的限定符可以看这里： 限定符 含义 * 匹配0次或多次 + 匹配1次或多次 ? 匹配0次或1次 {n} 匹配n次，n为数字 {n,} 匹配n次或多次（至少n次） {n,m} 最少匹配n次，最多匹配m次 由上可见，*相当于{0,}，+相当于{1,}，?相当于{0,1} 我们再看一个例子:1234var str = "123456aaaaa5678";var regExp = /\d&#123;3,5&#125;/gi;var result = str.match(regExp);console.log(result);// ["12345", "5678"] 上式中123其实也是满足我们的正则表达式，但是JS中的正则匹配是贪婪匹配的，他会尽可能多的去匹配。 定位符 定位符可以将一个正则表达式固定在一行的开始或结束。也可以固定在单词的开始或结尾出。 定位符 含义 ^ 匹配开始的位置 $ 匹配结束的位置 \b 匹配一个单词边界，前面是开始位置或者后面是结束位置，或者有空格 \B 匹配非单词边界 如var regExp = /^h/gi;匹配以h开头的内容，var regExp = /ld$/gi;匹配以ld结尾的内容。 常用匹配规则 匹配规则 含义 [a-z] 标示a-z任意一个字符 [A-Z] 标示A-Z任意一个字符 [0-9] 标示0-9任意一个字符 [0-9A-Z] 标示0-9或者A-Z任意一个字符 [abcd] 标示a或者b或者c或者d [^A-Z] 标示排除A-Z外的任意一个字符 \d 匹配一个数字，即[0-9] \D 匹配一个非数字，即[^0-9] \w 匹配单词字符，也就是数字字母下划线，即[0-9a-zA-Z_] \W 匹配非单词字符，如！￥等 \s 匹配空白字符，空格、换行、制表符等 \S 匹配非空白字符 . （看得清吗，一个点）匹配非换行外的任意字符 那如果要匹配所有的任意字符怎么办？是用[.\n]就可以了。这里列出了一些常用的匹配规则，更多更详细的规则可以看这里。 转义符转义符\用来转义正在表达式子中有特殊意义的符号。就比如匹配一个左括号，那么就需要转义一下var regExp = /\(/;。需要转义的字符有：(){}[]\/.*+?^$等。 预查 正向预查(?=) 1234var str = "雷锋好人，雷锋大好人";var regExp = /雷锋(?=好人)/gi;// 匹配后面是"好人"的雷锋 即第一个雷锋var result = str.match(regExp);console.log(result);// ["雷锋"] 负向预查(?!) 1234var str = "雷锋好人，雷锋大好人";var regExp = /雷锋(?!好人)/gi;// 匹配后面不是"好人"的雷锋 即第二个雷锋var result = str.match(regExp);console.log(result);// ["雷锋"] 结果不被捕获(?:) 123456// 捕获字母或者数字后面跟着两个相同的数字的内容var str = "a123b11";// 因为我们第一个是字母或数字需要上一个括号表示整体 但是我们不希望被捕获 var regExp = /(?:\d|\w)(\d)\1/gi;var result = str.match(regExp);console.log(result);// ["b11"] 经典案例将”我…我…..我..是.是….是一个个….个帅帅帅….帅帅帅哥”转化为”我是一个帅哥””。123456var str = "我...我.....我..是.是....是一个个....个帅帅帅....帅帅帅哥";var regExp = /\./gi;// 因为.是特殊字符 需要转义str = str.replace(regExp,"");// 第一步去掉空格regExp = /(.)\1+/gi;// 这里的点表示任意非换行字符 然后匹配多个 一定要注意这里必需有g标示str.replace(regExp,"$1");// $1类似于正则中的\1 console.log(str);// "我是一个帅哥"]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《高性能网站建设指南》读书笔记]]></title>
    <url>%2F2019%2F04%2F13%2F%E3%80%8A%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%AB%99%E5%BB%BA%E8%AE%BE%E6%8C%87%E5%8D%97%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[这本书是很久之前买的，今天回顾了一下，顺便记录一下笔记。本书的副标题是“前端工程师技能精髓”可见这本书的牛逼之处。这本书也很薄，只有147页，但是每一章都是精髓。由于这本书每章提出了一个性能优化的方法，我们也就按照每张的具体内容给出吧。 减少HTTP请求 性能黄金法则：只有10%~20%的最终用户响应时间花在了下载HTML文档上，其余的80%~90%时间花在了下载页面中的所有资源（图片、JS、CSS、音频等）上。 优化方法：使用图片地图（map标签）、CSS Sprites（雪碧图）、内联图片（base64图片）、脚本和样式的合并等。 使用CDN CDN（Content Delivery Network 内容发布网络）是一组分布在多个不同地理位置的Web服务器，用于更加有效地向用户发布内容。 优点： 可以选择网络阶跃数量最小的服务器，或者具有最短响应时间的服务器。 可以进行缓存。 缺点： 响应时间可能会受到其他网站的影响。 无法直接控制服务器所带来的特殊服务，如修改某个HTTP的响应头信息。 如果CDN服务的性能下降，你的工作质量也会随之下降。 添加Expires头信息Expires响应头：1Expires: Sun, 25 Mar 2029 09:16:01 GMT 如果某个资源使用这个响应头那么该资源会在这个时间内使用缓存。HTTP1.1引入了Cache-Control头来克服Expires的限制，Cache-Control使用max-age指令指定资源被缓存多久。它以秒为单位定义了一个时间，如果资源从上次请求的秒数到本次请求小于max-age，浏览器就使用缓存中的资源，就可以避免额外的HTTP请求。Cache-Control的优先级高于Expires，如果两者都有的时候对于支持HTTP1.1的浏览器使用的是Cache-Control，不支持的使用Expires。 Cache-Control响应头：1Cache-Control: max-age=31526000 对于HTML等经常变动的资源，不应该使用长久的Expires头信息。为了确保用户能获取资源的最新版本，需要在所有HTML页面中修改资源的文件名（如加版本号或者hash值）。 压缩资源从HTTP1.1开始，web客户端可以通过HTTP请求中的Accept-Encoding头来表示对压缩的支持： 1Accept-Encoding: gzip,deflate web服务器通过响应中的Content-Encoding来通知web客户端，使用了压缩: 1Content-Encoding: gzip 通常情况下图片和PDF不应该压缩，因为他们已经压缩过了。一般大于1KB或2KB的文件进行压缩。mod_gzip_minimum_file_size指令（Apache服务器）控制希望压缩文件的最小大小，默认是500B。 将CSS放在顶部也就是在head标签中使用link标签引入CSS。如果放在html文档的底部的时候，加载CSS会导致DOM回流（重排），浪费不必要的计算。 将JS放在底部也就是把JS放在body标签内部的最下面来引入。HTTP1.1建议浏览器从每个主机名并行地下载2个资源（不同浏览器的实现不同，可能不是2个），但是JS却不一样，JS下载时只有一个，而往往JS也是比较大的所以会阻塞其他资源的下载。将JS放在底部将不会阻塞后面内容的呈现，也不会阻塞后面其他资源的下载，还可以防止DOM操作报错。 避免CSS表达式现在CSS表达式真的很少使用了，估计大多数人还不知道这玩意，谷歌浏览器都不支持：1background-color: expression((new Date()).getHours() % 2 ? "red" : "blue") 使用外部JS和CSS单纯来讲，使用内联引入资源比外部引入快30%~50%，主要是因为外部资源需要承担更多的HTTP请求。但是有缓存的时候就差不多了，但是放在外部还可以实现资源的复用。 减少DNS查找DNS将会把域名映射到ip上。减少DNS查找的意思就是浏览器和web服务器愉快的通讯着，并保持TCP连接打开的状态，就没有理由进行DNS查找。服务器可以设置TTL（Time-to-live）值告诉客户端DNS记录可以缓存多久。当然也可以设置Keep-alive头信息:1Connection: Keep-alive 精简JS和CSS其实就是把JS和CSS代码压缩。所谓压缩就是去掉空格、换行符和制表符并进行一些优化（比如CSS使用0代替0px等）。 避免重定向要避免响应码为301或者302这样的请求，会导致页面变慢。 删除重复脚本这个就不用说了，提高代码的利用率。 配置或删除ETagETag（Entity Tag，实体标签）是web服务器和浏览器用于确定缓存资源的一种有效机制。它是唯一表示了一个资源的一个特定的版本的字符串。唯一的格式约束是该字符串必须用引号引用起来。1ETag: "10c24bc-4ab-457e1c1f" 通常应用处于一个机子的时候那么建议配置ETag，但是如果应用处于一个集群的时候，建议不使用ETag。因为浏览器如果从集群的一台机子中获取了资源，然后再次请求资源的时候如果是另一台的时候，那么两个机子生成的ETag往往是不一样的，这样就会使得缓存失效。 使Ajax可缓存将Ajax缓存了可以提高性能这是肯定的，这也正是一些库默认使用了缓存，如果为了提高请求的准确性，个人觉的这条规则可以忽略。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>前端性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速排序]]></title>
    <url>%2F2019%2F04%2F10%2F%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[快速排序是最效率极高的一种排序方法，正因为它效率高，所以也受到了面试官的青睐，同样成了程序员必会的内容。O(∩_∩)O哈哈~ 它的思想是选一个基准，然后把小于基准的值放在左边，大于基准的值放在右边（假设从小到大排序）。然后分别递归左边和右边的部分，当所有的递归完毕后就是已经排好序的结果了。 市面上流传最广的快速排序是阮一峰老师博客中写的，我们这笔直接拿过来记录一下，原文在这里。 123456789101112131415var quickSort = function(arr) &#123; if (arr.length &lt;= 1) &#123; return arr; &#125; var pivotIndex = Math.floor(arr.length / 2); var pivot = arr.splice(pivotIndex, 1)[0]; var left = []; var right = []; for (var i = 0; i &lt; arr.length; i++)&#123; if (arr[i] &lt; pivot) &#123; left.push(arr[i]); &#125; else &#123; right.push(arr[i]); &#125; &#125; return quickSort(left).concat([pivot], quickSort(right));&#125;; 阮一峰老师的快速排序选择的是最中间的元素作为基准，左边和右边的都定义了一个新的数组来接收，最后把数组连接起来。这个快速排序的优点是思路很明确，缺点是因为定义了新的数组所以空间复杂度比较高。那如何降低空间复杂度呢？其实只要操作元数组就可以了，这里给出另一种快速排序的实现： 1234567891011121314151617181920212223242526272829303132333435363738function sort(arr,low,high)&#123; // 用i和j记录下初始的最低位和最高位 temp记录下基准 这里假设是起始位置 var i = low,j = high,temp = arr[i]; while (i &lt; j) &#123;// 如果低位的小于高位的时候那么对立面的值进行交换 while (i &lt; j &amp;&amp; temp &lt;= arr[j]) &#123;// 扫描右边 如果右边的的有比temp小的需要交换 j--; &#125; // 判断i &lt; j为了避免不需要交换的情况 下同 if (i &lt; j) &#123;// 如果右边的有交换的情况则放在左边的位置 arr[i] = arr[j]; i++; &#125; while (i &lt; j &amp;&amp; arr[i] &lt; temp) &#123;// 扫描左边 如果左边的的有比temp大的需要交换 i++; &#125; if (i &lt; j) &#123;// 如果左边的有交换的情况则放在有边的位置 arr[j] = arr[i]; j--; &#125; &#125; // 上面循环结束的时候i位置左边的都比temp小 右边的都比temp大 这只temp给当前位置 arr[i] = temp; if (low &lt; i) &#123; sort(arr,low,i - 1);// 递归遍历左侧 &#125; if (j &lt; high) &#123; sort(arr,j + 1,high);// 递归遍历右侧 &#125; return arr;&#125;function quickSort(arr)&#123;// 为了给sort传初始值 而封装的一层 return sort(arr,0,arr.length - 1);&#125;var arr = [8,3,10,7,5,6,4,2,1,9];quickSort(arr);console.log(arr);// [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 这个快速的时间复杂度要比阮一峰老师的稍微低一点，不过比阮一峰老师的快速排序稍微难理解一点。其实我们在《JavaScript数据结构与算法》读书笔记一文中也有快速排序的记录，那个快速排序与这个有一点点的不同，那个排序的基准选择的中间值，然后每次循环直接交换左侧的和右侧的元素，整体思路相差无几，感兴趣的可以在那篇文章中搜一下快速排序。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>快速排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[冒泡排序]]></title>
    <url>%2F2019%2F04%2F10%2F%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[冒泡排序是最简单的一种排序方法，正因为它很简单，所以受到了面试官的青睐，成了程序员必会的内容。 它的思想是通过两次循环，如果前一个比后一个小的时候那么两者互换位置（假设是从小到大排序）。就这样大的数就会像水中的气泡一样从前面逐渐走到后面，这也正式名字的由来。 这里给出冒泡排序的实现，里面使用了flag进行标记，如果已经排好序的数组那么就不需要多次遍历了： 1234567891011121314151617181920function bubbleSort(arr)&#123; var flag = true; // 标记某次循环是否执行完毕 for(var i = 0; i &lt; arr.length - 1 &amp;&amp; flag; i++)&#123; flag = false; // 如果本次循环没有交换 说明已经已经是排好序的 不需要再遍历了 for(var j = 0; j &lt; arr.length - 1 - i; j++)&#123; // 如果前面的比后面的大 那么交换元素 if(arr[j] &gt; arr[j + 1])&#123; var temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; flag = true;// 有交换的时候 说明很可能还没有排好序 &#125; &#125; &#125; return arr;&#125;var arr = [8,3,10,7,5,6,4,2,1,9];bubbleSort(arr);console.log(arr);// [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>冒泡排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[防抖与节流]]></title>
    <url>%2F2019%2F04%2F09%2F%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81%2F</url>
    <content type="text"><![CDATA[防抖 防抖：多次触发某个函数，以最后一次函数的执行为准。 也就是说给定了一个时间n，如果在n毫秒内重复执行某个函数那么将不会执行，如果n毫秒内不再触发这个函数，那么将执行该函数。表现的效果是如果一直触发函数，那么只有最后一次才会执行。 简单实现:12345678910111213function debounce(func, wait) &#123; var timeout; return function () &#123; var context = this; var args = arguments; clearTimeout(timeout) timeout = setTimeout(function()&#123; func.apply(context, args) &#125;, wait); &#125;&#125; 简单使用:123456var fn = debounce(function ()&#123; console.log("函数执行了");&#125;,500);fn();// 第一次 并不会执行fn();// 第二次 并不会执行fn();// 第三次 由于500毫秒后没有再次执行 所以会在500毫秒后打印"函数执行了" 防抖适用场景：多次重复的操作以最后一个为准的。就比如列表页有一个查询按钮，往往我们多次查询的结果都是以最后一次的结果为准，这里就可以用防抖。 节流 节流：多次触发某个函数，一段时间内只执行一次。 也就是说给定了一个时间n，如果在n毫秒内该函数多次调用那么会忽略这些调用，等n毫秒后会执行该函数。表现的效果是如果一直触发函数，那么每隔n毫秒就会执行一次函数。 简单实现:1234567891011121314function throttle(func, wait) &#123; var timeout = null; return function() &#123; var context = this; var args = arguments; if (!timeout) &#123; timeout = setTimeout(function()&#123; timeout = null; func.apply(context, args) &#125;, wait) &#125; &#125;&#125; 节流适用场景：将密集型操作，转换为相对松散型的操作,以减小计算量。就比如onmousemove和onresize事件的处理等。 lodash库已经对防抖和节流做了实现，我们可以直接使用。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>防抖</tag>
        <tag>节流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript易错点（长期更新）]]></title>
    <url>%2F2019%2F04%2F08%2FJavaScript%E6%98%93%E9%94%99%E7%82%B9%EF%BC%88%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[下面输出的是什么12345678function F ()&#123;&#125;;F.prototype = null;var o1 = new F();console.log(F.prototype);console.log(o1.__proto__);var o2 = Object.create(null);console.log(o2.__proto__); 答案： nullobjectundefined 点评:new的时候，如果构造函数的原型是是object类型那么浏览器会添加o1.__proto__ = F.prototype否则会添加o1.__proto__ = Object.prototype 下面输出的是什么1234(function ()&#123; let a = this ? class b&#123;&#125; :class c&#123;&#125;; console.log(typeof a,typeof b, typeof c);&#125;)(); 答案： function undefined undefined 点评:class和function处于等式右边的时候不会向外暴露类名和函数名 下面输出的是什么12345678910var arr1 = "john".split('');var arr2 = arr1.reverse();var arr3 = "jones".split('');arr2.push(arr3);console.log("array 1: length=" + arr1.length + " last=" + arr1.slice(-1));console.log("array 2: length=" + arr2.length + " last=" + arr2.slice(-1)); 答案： array 1: length=5 last=j,o,n,e,sarray 2: length=5 last=j,o,n,e,s 点评:reverse会改变原数组，所以arr1和arr2其实是一个数组 下面输出的是什么123456var a = &#123;&#125;, b = &#123;key:'b'&#125;,c = &#123;key:'c'&#125;;a[b] = 123;a[c] = 456;console.log(a[b]); 答案： 456 点评:[]访问属性的时候对于对象会调用toString方法，b和c的toString的结果都是[object Object] 下面输出的是什么12345var a = &#123;n:1&#125;;var b = a;a.x = a = &#123;n:2&#125;;console.log(a.x);console.log(b.x); 答案： undefined{n: 2} 点评:执行第三行那个等式的时候，a.x先进入栈，此时a和b应该是一样的。之后后面那个等式进栈并执行，后面的结果把a改了，也就是a变成{n:2}了，返回的结果也是{n:2}。此时前面的a.x的地址就是b.x的地址，所以b.x = {n:2}。 下面输出的是什么12345678console.log(Number());console.log(Number(undefined));console.log(Number(null));console.log(Number("012"));console.log(Number("abc"));console.log(Number(&#123;valueOf:()=&gt;123&#125;));console.log(Number(&#123;toString:()=&gt;456&#125;));console.log(Number(&#123;valueOf:()=&gt;123,toString:()=&gt;456&#125;)); 答案： 0NaN012NaN123456123 点评:Number转换的时候不传值和传入null的时候是0；如果是undefined的时候然后的是NaN；字符串会忽略前置的0（而不是8进制）；不以数字开头的是NaN；对象会调用valueOf()方法，如果结果用Number转化后还是NaN，那么就会用toString()的结果再转换一次。 下面输出的是什么123console.log(parseFloat("0xA"));console.log(parseInt("0xA"));console.log(parseInt("012")); 答案： 01012 点评:parseFloat对于16进制的都换转化为0，parseInt对0开头的都会忽略（ES3的时候是按照8进制转换的）。 下面输出的是什么1234console.log(Number.POSITIVE_INFINITY + Number.POSITIVE_INFINITY);console.log(Number.POSITIVE_INFINITY + Number.NEGATIVE_INFINITY);console.log(Number.NEGATIVE_INFINITY + Number.NEGATIVE_INFINITY);console.log(1 + NaN); 答案： InfinityNaN-InfinityNaN 点评:正无穷加正无穷等于正无穷，负无穷加负无穷等于负无穷，正无穷加负无穷不是个数，不是个数加其他数任然不是个数。 下面输出的是什么123console.log(NaN &lt; 0);console.log(NaN = 0);console.log(NaN &gt; 0); 答案： falsefalsefalse 点评:NaN和任何数字比较都是false。 下面输出的是什么12var d = (a = 1,b = 2,c = 3);console.log(d); 答案： 3 点评:逗号表达式返回最后一个。 下面输出的是什么1console.log(123 instanceof Number); 答案： false 点评:123的数据类型是number而不是object，所有不是对象的数据类型使用instanceof都返回false。 下面输出的是什么12console.log(new Array(3,2,1));console.log(new Array(3)); 答案： [3, 2, 1][undefined, undefined, undefined] 点评:new Array的时候多个参数的时候会认为是数组的内容，一个参数的时候会认为是数组的长度。 下面输出的是什么12345678910111213function F1 ()&#123; return 123;&#125;function F2 ()&#123; return &#123;name:"不告诉你"&#125;;&#125;function F3 ()&#123; return this;&#125;console.log(new F1());console.log(new F2());console.log(new F3()); 答案： F1 {}{name: “不告诉你”}F3 {} 点评:new的时候如果构造方法返回的是一个对象，那么new的结果就是这个对象，否则创建一个对象，新创建的对象的原型指向构造方法的原型。 下面输出的是什么123456789101112function fn ()&#123; try&#123; return 0; throw new Error("我就要抛出错误"); &#125; catch (e)&#123; return 1; &#125; finally &#123; return 2; &#125;&#125;console.log(fn()); 答案： 2 点评:finally一定会执行，即使有return也阻止不了。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>易错点</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3卡片光照效果]]></title>
    <url>%2F2019%2F03%2F25%2FCSS3%E5%8D%A1%E7%89%87%E5%85%89%E7%85%A7%E6%95%88%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[我们今天要使用CSS3实现下面这样的卡片光照效果： 实现首先给出HTML结构：1&lt;div class="hover-light"&gt;卡片光照效果&lt;/div&gt; 然后给出初始的CSS结构: 12345678910.hover-light&#123; width: 250px; height: 180px; margin: 0 auto; background: #70c3ff; color:white; font-size: 2rem; text-align: center; border-radius: 8px;&#125; 此时效果大概是这个样子: 要实现卡片光照的效果，我们需要添加子元素，此时使用伪元素::after是最好的选择。我们需要给::after添加一个斜着的渐变来模拟光照效果，这里我们使用从左到右的渐变，然后再给一个倾斜的形变就可以模拟了。最好再给一个简单的悬浮动画就完事了。下面直接给出CSS的其他代码： 12345678910111213141516171819202122232425262728293031323334353637383940.hover-light&#123; width: 250px; height: 180px; margin: 0 auto; background: #70c3ff; color:white; font-size: 2rem; text-align: center; border-radius: 8px; /*子绝父相对*/ position: relative; /*子溢出父元素隐藏 这样hover子元素的时候 不算hover父元素*/ overflow: hidden;&#125;.hover-light::after&#123; content: ""; position: absolute; /*首先隐藏子元素*/ left: -100%; top: 0; /*设置和父元素一样大*/ width: 100%; height: 100%; /*添加从左往右的渐变 即模仿光照效果*/ background-image: -webkit-linear-gradient(0deg,hsla(0,0%,100%,0),hsla(0,0%,100%,.5),hsla(0,0%,100%,0)); background-image: linear-gradient(to right,hsla(0,0%,100%,0),hsla(0,0%,100%,.5),hsla(0,0%,100%,0)); /*光照是斜着的更好看*/ -o-transform: skewx(-25deg); -moz-transform: skewx(-25deg); -webkit-transform: skewx(-25deg); transform: skewx(-25deg); /*添加动画效果*/ transition: all .3s ease;&#125;.hover-light:hover::after &#123; /*鼠标放在父元素上 移动子元素*/ left: 100%;&#125; 通过这样就实现了上面的卡片光照效果! 进阶上面光照效果已经完成，其实CSS3的形变投影等功能组合起来可以实现更好的效果，我们现在添加样式，给父元素也添加一个动画的效果： 12345678910111213141516171819202122.hover-light&#123; /*... 其他代码相上*/ transition: all .3s ease;&#125;.hover-light::after&#123; /*... 其他代码相上*/ /*添加动画效果 直接继承父类的效果*/ transition: inherit;&#125;.hover-light:hover &#123; /*向上移动6个像素*/ -moz-transform: translateY(-6px); -webkit-transform: translateY(-6px); transform: translateY(-6px); /*添加一个淡一点的阴影*/ -moz-box-shadow: 0 26px 40px -24px rgba(0,36,100,.5); -webkit-box-shadow: 0 26px 40px -24px rgba(0,36,100,.5); box-shadow: 0 26px 40px -24px rgba(0,36,100,.5);&#125; 此时的效果： 完整HTML代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;CSSS3卡片光照效果&lt;/title&gt; &lt;style&gt; body&#123; padding: 20px; &#125; .hover-light&#123; width: 250px; height: 180px; margin: 0 auto; background: #70c3ff; color:white; font-size: 2rem; text-align: center; border-radius: 8px; /*子绝父相对*/ position: relative; /*子溢出父元素隐藏 这样hover子元素的时候 不算hover父元素*/ overflow: hidden; transition: all .3s ease; &#125; .hover-light::after&#123; content: ""; position: absolute; /*首先隐藏子元素*/ left: -100%; top: 0; /*设置和父元素一样大*/ width: 100%; height: 100%; /*添加从左往右的渐变 即模仿光照效果*/ background-image: -webkit-linear-gradient(0deg,hsla(0,0%,100%,0),hsla(0,0%,100%,.5),hsla(0,0%,100%,0)); background-image: linear-gradient(to right,hsla(0,0%,100%,0),hsla(0,0%,100%,.5),hsla(0,0%,100%,0)); /*光照是斜着的更好看*/ -o-transform: skewx(-25deg); -moz-transform: skewx(-25deg); -webkit-transform: skewx(-25deg); transform: skewx(-25deg); /*添加动画效果 直接继承父类的效果*/ transition: inherit; &#125; .hover-light:hover::after &#123; /*鼠标放在父元素上 移动子元素*/ left: 100%; &#125; .hover-light:hover &#123; /*向上移动6个像素*/ -moz-transform: translateY(-6px); -webkit-transform: translateY(-6px); transform: translateY(-6px); /*添加一个淡一点的阴影*/ -moz-box-shadow: 0 26px 40px -24px rgba(0,36,100,.5); -webkit-box-shadow: 0 26px 40px -24px rgba(0,36,100,.5); box-shadow: 0 26px 40px -24px rgba(0,36,100,.5); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="hover-light"&gt;卡片光照效果&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS效果</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3实现彩色炫酷文字]]></title>
    <url>%2F2019%2F03%2F19%2FCSS3%E5%AE%9E%E7%8E%B0%E5%BD%A9%E8%89%B2%E7%82%AB%E9%85%B7%E6%96%87%E5%AD%97%2F</url>
    <content type="text"><![CDATA[我们今天要使用CSS3实现下面这样的酷酷的效果： 要实现这样的效果只需要三步： 设置渐变背景色； 按照文字拆分背景； 去掉文字本身的颜色； 设置动画。 我们也按照这个步骤一步一步的写出样式，首先给出HTML结构：1&lt;div class="color-text"&gt;这里是彩色的文字&lt;/div&gt; 然后给出初始的CSS结构:1234.color-text &#123; text-align: center; font-size: 40px;&#125; 此时效果大概是这个样子: 一、设置渐变背景色12345678910.color-text &#123; text-align: center; font-size: 40px; background-image: -webkit-linear-gradient(left, blue, #66ffff 10%, #cc00ff 20%, #CC00CC 30%, #CCCCFF 40%, #00FFFF 50%, #CCCCFF 60%, #CC00CC 70%, #CC00FF 80%, #66FFFF 90%, blue 100%);&#125; 这里需要注意一点是渐变背景色应该是按照50%对称的不然就会出现断层。这个时候的效果大概是这个样子了： 二、按照文字拆分背景1234567891011.color-text &#123; text-align: center; font-size: 40px; background-image: -webkit-linear-gradient(left, blue, #66ffff 10%, #cc00ff 20%, #CC00CC 30%, #CCCCFF 40%, #00FFFF 50%, #CCCCFF 60%, #CC00CC 70%, #CC00FF 80%, #66FFFF 90%, blue 100%); -webkit-background-clip: text;&#125; 此时的效果是： 咦？貌似没什么效果？其实仔细看你可以看到文字已经不是默认的那种黑色了，其实已经生效了，只是字体本身的颜色把背景色覆盖了。 三、去掉文字本身的颜色123456789101112.color-text &#123; text-align: center; font-size: 40px; background-image: -webkit-linear-gradient(left, blue, #66ffff 10%, #cc00ff 20%, #CC00CC 30%, #CCCCFF 40%, #00FFFF 50%, #CCCCFF 60%, #CC00CC 70%, #CC00FF 80%, #66FFFF 90%, blue 100%); -webkit-background-clip: text; color: transparent;&#125; 去掉字体本身的颜色CSS3还有一种方法叫text-fill-color他可以设置文字的填充色优先级比color高，我们也可以使用它来代替color: transparent;：1-webkit-text-fill-color: transparent; 此时的效果是: 四、设置动画12345678910111213141516171819202122232425262728.color-text &#123; text-align: center; font-size: 40px; /* 设置背景透明色 */ background-image: -webkit-linear-gradient(left, blue, #66ffff 10%, #cc00ff 20%, #CC00CC 30%, #CCCCFF 40%, #00FFFF 50%, #CCCCFF 60%, #CC00CC 70%, #CC00FF 80%, #66FFFF 90%, blue 100%); /* 改变background-size是为了让动画动起来 */ background-size: 200% 100%; /* 按照文字拆分背景 */ -webkit-background-clip: text; /* 将字体设置成透明色 */ -webkit-text-fill-color: transparent; /* 启用动画 */ animation: masked-animation 4s linear infinite;&#125;@keyframes masked-animation &#123; 0% &#123; background-position: 0 0; &#125; 100% &#123; background-position: -100% 0; &#125;&#125; 通过这样设置我们就大功告成了! 进阶上面使用到了text-fill-color，我们可以在这里看看它的兼容性。它的一大用途就是上面这样设置炫酷的彩色文字，还有一个用途就是设置镂空文字，如下。HTML：1&lt;div class="hollow-out-text"&gt;镂空文字&lt;/div&gt; CSS：12345678.hollow-out-text&#123; text-align: center; font-size: 40px; /*设置背景透明*/ -webkit-text-fill-color: transparent; /*设置镂空线条*/ -webkit-text-stroke: 1px #cc00ff;&#125; 最终效果：]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS效果</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何判断一个对象是不是数组]]></title>
    <url>%2F2019%2F03%2F17%2F%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%98%AF%E4%B8%8D%E6%98%AF%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[使用instanceof 1234// 如果返回true那么说明就是数组if (value instanceof Array)&#123;&#125; 使用Object.prototype.toString 1234// 由于数组重写了toString方法，我们可以使用Object.prototype.toString方法来判断对象是不是数组if (Object.prototype.toString.call(value) === "[object Array]")&#123;&#125; 使用value.constructor.name 1234// 检测构造函数的名称是不是Arrayif (value.constructor.name === "Array")&#123;&#125; 使用ES5的Array.isArray() 1234// ES5标准 简单 好用 低版本浏览器不支持if (Array.isArray(value))&#123;&#125;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>判断数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《JavaScript函数式编程指南》读书笔记]]></title>
    <url>%2F2019%2F03%2F10%2F%E3%80%8AJavaScript%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[老规矩，这篇文章记录书中的重点部分，外加自己的见解，不会对全书进行复述，但记录的绝对是最重要的部分，想要了解跟多内容请看原版图书。 函数式编程的目标：使用函数来抽象作用在数据之上的控制流与操作，从而在系统中消除副作用并减少对状态的改变。 纯函数所具有的性质： 仅取决于提供的输入，而不依赖于任何在函数求值期间或调用间隔时可能变化的隐藏状态和外部状态。不会造成或超出其作用域的变化。如修改全局变量对象或引用传递的参数。 引用透明：如果一个函数对于相同的输入始终产生相同的结果，那么说它是引用透明的。 函数式编程是指为创建不可变的程序，通过消除外部可见的副作用，来对纯函数的声明式的求值过程。 高阶函数：某些函数可以接收其它的函数作为参数，或者返回一个函数，这样的函数称为高阶函数。 map函数的简单实现：12345678function map(arr, fn) &#123; const len = arr.length, result = new Array(len); for (let idx = 0; idx &lt; len; ++idx) &#123; result[idx] = fn(arr[idx], idx, arr); &#125; return result;&#125; reduce函数的简单实现：1234567891011function reduce(arr, fn,accumulator) &#123; let idx = -1, len = arr.length; if (!accumulator &amp;&amp; len &gt; 0) &#123; accumulator = arr[++idx]; &#125; while (++idx &lt; len) &#123; accumulator = fn(accumulator,arr[idx], idx, arr); &#125; return accumulator;&#125; filter函数的简单实现：123456789101112function filter(arr, predicate) &#123; let idx = -1, len = arr.length, result = []; while (++idx &lt; len) &#123; let value = arr[idx]; if (predicate(value, idx, this)) &#123; result.push(value); &#125; &#125; return result;&#125; lodash对象已经定义了好了很多函数，在本章中_代表lodash对象。使用lodash的reduce对数组求和：1_([0,1,3,4,5]).reduce(_.add); //-&gt; 13 实战：格式化名字12345678910111213var names = ['alonzo church', 'Haskell curry', 'stephen_kleene', 'John Von Neumann', 'stephen_kleene'];const isValid = val =&gt; !_.isUndefined(val) &amp;&amp; !_.isNull(val);_.chain(names) .filter(isValid) .map(s =&gt; s.replace(/_/, ' ')) .uniq() .map(_.startCase) .sort() .value(); //-&gt; ['Alonzo Church', 'Haskell Curry', 'Jon Von Neumann', 'Stephen Kleene'] _.chain可以添加一个输入对象（或数组）的状态，从而能将这些输入转换为所需输出的操作链接在一起。_.chain的另一个好处是可以惰性计算，在调用value()前并不会真正的执行任何操作。它返回的是一个lodash包装对象，而不是原生的对象。 像写SQL一样编程假如有SQL语句：123SELECT p.firstname FROM Person pWHERE p.birthYear &gt; 1903 and p.country IS NOT 'US'ORDER BY p.firstname 使用_.mixin可以给lodash对象添加新的函数（这里其实相当于起别名），如：1234_.mixin(&#123;'select': _.map, 'from': _.chain, 'where': _.filter, 'sortBy': _.sortByOrder&#125;); 那么查询语句就可以修改为：12345_.from(persons) .where(p =&gt; p.birthYear &gt; 1903 &amp;&amp; p.address.country !== 'US') .sortBy(['firstname']) .select(p =&gt; p.firstname) .value(); 递归求和12345678function sum(arr) &#123; if(_.isEmpty(arr)) &#123; return 0; &#125; return _.first(arr) + sum(_.rest(arr));//_.first获取的是第一个值 _.rest是剩下的值&#125;sum([]); //-&gt; 0sum([1,2,3,4,5,6,7,8,9]); //-&gt;45 尾递归的递归求和123456function sum(arr, acc = 0) &#123; if(_.isEmpty(arr)) &#123; return 0; &#125; return sum(_.rest(arr), acc + _.first(arr));&#125; 元数：函数所接受的参数数量，也被称为函数的长度。 柯里化：柯里化是一种在所有参数被提供之前，挂起或“延迟”函数执行，将多个参数转化为一元函数序列的技术。如一个三个参数的柯里化函数定义：curry(f) :: ((a,b,c) -&gt; d) -&gt; a -&gt; b -&gt; c -&gt; d。 一个二元柯里化的实现：12345678910111213function curry2(fn) &#123; return function(firstArg) &#123; return function(secondArg) &#123; return fn(firstArg, secondArg); &#125;; &#125;;&#125;function add (a,b)&#123; return a + b;&#125;var curry2AddFn = curry2(add);curry2AddFn(1)(2);// 3 多元柯里化实现：123456789101112131415161718function curry(fn, ...args) &#123; const length = fn.length let lists = args || [] let listLen return function (..._args) &#123; lists = [...lists, ..._args] listLen = lists.length if (listLen &lt; length) &#123; const that = lists lists = [] return curry(fn, ...that) &#125; else if (listLen === length) &#123; const that = lists lists = [] return fn.apply(this, that) &#125; &#125;&#125; 应用部分：应用部分是一种通过将函数的不可变参数自己初始化为固定值来创建更小元数函数的操作。就比如一个5个参数的函数我们通过应用部分可以定义为一个给定了2个特定参数的函数，那么调用的时候只要给另外三个就行了。 应用部分的实现：1234567891011121314151617function partial() &#123; let fn = this, boundArgs = Array.prototype.slice.call(arguments); let placeholder = &lt;&lt;partialPlaceholderObj&gt;&gt;;// &lt;&lt;partialPlaceholderObj&gt;&gt; 是一个占位符 通常用undefined lodash使用的是_ let bound = function() &#123; let position = 0, length = args.length; let args = Array(length); for (let i = 0; i &lt; length; i++) &#123; args[i] = boundArgs[i] === placeholder ? arguments[position++] : boundArgs[i]; &#125; while (position &lt; arguments.length) &#123; args.push(arguments[position++]); &#125; return fn.apply(this, args); &#125;; return bound;&#125;); 实战1：使用lodash的应用部分对核心语言扩展。12345678910111213141516// 注意lodash中的占位符是_，也就是_.partial参数中的_会在调用时替换为调用时的参数// 获取字符串前几个子串String.prototype.first = _.partial(String.prototype.substring, 0, _);'Functional Programming'.first(3); // -&gt; 'Fun'// 将名字转化为[Last, First]格式String.prototype.asName = _.partial(String.prototype.replace, /(\w+)\s(\w+)/, '$2, $1');'Alonzo Church'.asName(); //-&gt; 'Church, Alonzo'// 实现类似于split的效果String.prototype.explode = _.partial(String.prototype.match, /[\w]/gi);'ABC'.explode(); //-&gt; ['A', 'B', 'C']// 解析URL String.prototype.parseUrl = _.partial(String.prototype.match,/(http[s]?|ftp):\/\/([^:\/\s]+)\.([^:\/\s]&#123;2,5&#125;)/); 'http://example.com'.parseUrl(); // -&gt; [ 'http://example.com', 'http', 'example', 'com' ] 实战2：生成特定秒数的延迟函数。12345678910111213141516const Scheduler = (function () &#123; // lodash中_也可用于_.bind中 表示占位符 // _.bind的第一个参数是要绑定的函数 第二个函数是宿主对象 之后的参数是绑定函数的参数 // 下例中两个占位符相当于都是setTimeout函数的参数 他的第一个参数是一个函数 第二个参数是毫秒数 const delayedFn = _.bind(setTimeout, undefined, _, _); // 下面相当于把setTimeout第一个参数使用调用的函数 第二个参数也就是时间给5000 10000 或者 自己传进去 return &#123; delay5: _.partial(delayedFn, _, 5000), delay10: _.partial(delayedFn, _, 10000), delay: _.partial(delayedFn, _, _) &#125;;&#125;)();Scheduler.delay5(function () &#123; consoleLog('Executing After 5 seconds!')&#125;); 函数组合：函数组合是一种将已被分割的简单任务组织成复杂行为的整体过程。定义如下：12345g :: A -&gt; B //函数g输入A返回Bf :: B -&gt; C //函数f输入B返回C//那么f和g的组合 可以定义为一个函数输入f和g 生成一个可以输入A 直接变成C的函数f ● g = f(g) = compose :: ((B -&gt; C), (A -&gt; B)) -&gt; (A -&gt; C) 组合的实现：1234567891011function compose(/* fns */) &#123; let args = arguments; let start = args.length - 1; return function() &#123; let i = start; let result = args[start].apply(this, arguments); while (i--) result = args[i].call(this, result); return result; &#125;;&#125; identity（I-组合子）：返回和参数相同的组合子。1234// identity :: (a) -&gt; afunction identity(value) &#123; return value;&#125; 注意：这里的组合子只写了单纯的一层的实现，实际使用的时候都是柯里化后的结果。就比如identity组合子其实是R.curry(identity)，柯里化后的组合子操作起来更方便。 tap（K-组合子）：将没有函数返回值的函数返回输入值。12345// tap :: (a -&gt; *) -&gt; a -&gt; avar tap = function tap(fn, x) &#123; fn(x); return x;&#125; alt（OR-组合子）：如果第一个函数返回有值，那么就返回第一个函数的返回值否则返回第二个参数的返回值。12345678const alt = function (func1, func2) &#123; return function (val) &#123; return func1(val) || func2(val); &#125;&#125;;//使用Ramda的实现const alt = (func1, func2, val) =&gt; func1(val) || func2(val); seq（S-组合子）：两个或者多个函数作为参数并返回一个新的函数，会用相同的值顺序调用所有的这些函数。12345678const seq = function(/*funcs*/) &#123; const funcs = Array.prototype.slice.call(arguments); return function (val) &#123; funcs.forEach(function (fn) &#123; fn(val); &#125;); &#125;;&#125;; fork（join-组合子）：需要三个函数作为参数，即以一个join函数将两个fork函数的处理结果再次进行处理。12345const fork = function(join, func1, func2)&#123; return function(val) &#123; return join(func1(val), func2(val)); &#125;;&#125;; 函数式编程空值的处理：Functor和Monad。函数式编程对空值的处理通常不是用try-catch和判断是否为空来处理，它的处理方式通常是在外面包一层数据结构。类似与jQuery处理DOM元素一样，会包装一层jQuery对象，这样如果没有找到DOM元素处理起来也不会报错。 Functor（函子）是一个可以将函数应用到它包裹的值上，并将结果再包裹起来的数据结构。12345678910111213141516171819202122232425262728293031323334353637383940class Wrapper &#123; constructor(value) &#123; this._value = value; &#125; // map :: (A -&gt; B) -&gt; A -&gt; B map(f) &#123; return f(this._value); &#125;; toString() &#123; return 'Wrapper (' + this._value + ')'; &#125;&#125;// wrap :: A -&gt; Wrapper(A)const wrap = (val) =&gt; new Wrapper(val);// fmap :: (A -&gt; B) -&gt; Wrapper[A] -&gt; Wrapper[B] // 这个地方其实就是FunctorWrapper.prototype.fmap = function (f) &#123; return wrap(f(this._value));&#125;;const wrappedValue = wrap('Get Functional');//将字符串包裹起来// 还记得前面说的组合子identity吗 就是这么使用的 这里可以获取到被包装的内容 wrappedValue.map(R.identity); // 'Get Functional'// 也可以做其他处理wrappedValue.map(console.log); wrappedValue.map(R.toUpper); //-&gt; 'GET FUNCTIONAL'//使用fmapconst plus = R.curry((a, b) =&gt; a + b);const plus3 = plus(3);const two = wrap(2);const five = two.fmap(plus3); //-&gt; Wrapper(5)five.map(R.identity); //-&gt; 5const plus10 = plus(10);const fifteen = two.fmap(plus3).fmap(plus10); //-&gt; Wrapper(15)fifteen.map(R.identity);//-&gt; 15 Functor的局限性：使用compose组合包装函数后会有多层包装结构，也就是需要多个.map(R.identity)来抽出结果，比较麻烦。可以使用Monad来处理。 1234567891011121314151617181920212223242526272829303132333435363738class Wrapper &#123; constructor(value) &#123; this._value = value; &#125; // Wrapper.of其实就是创建对象 static of(a) &#123; return new Wrapper(a); &#125; map(f) &#123; return Wrapper.of(f(this._value)); &#125; // 递归抽离值 join() &#123; if(!(this._value instanceof Wrapper)) &#123; return this; &#125; return this._value.join(); &#125; get() &#123; return this._value; &#125; toString() &#123; return `Wrapper ($&#123;this._value&#125;)`; &#125;&#125;//简单使用var msg = Wrapper.of('Hello Monads!') .map(R.toUpper) .map(R.identity); //-&gt; Wrapper('HELLO MONADS!')// 无论多少层只要调用.join就会返回最后一层msg.join();//-&gt; Wrapper('HELLO MONADS!')msg.join().get();//-&gt; 'HELLO MONADS!' Maybe Monad用来处理是否为空的判断逻辑。它有2个具体的类型：Just和Nothing。 Just(value)表示有值时的容器。Nothing()表示没有值时的容器。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879class Maybe &#123; static just(a) &#123; return new Just(a); &#125; static nothing() &#123; return new Nothing(); &#125; static fromNullable(a) &#123; return a !== null ? Maybe.just(a) : Maybe.nothing(); &#125; static of(a) &#123; return just(a); &#125; get isNothing() &#123; return false; &#125; get isJust() &#123; return false; &#125;&#125;class Just extends Maybe &#123; constructor(value) &#123; super(); this._value = value; &#125; get value() &#123; return this._value; &#125; map(f) &#123; return Maybe.fromNullable(f(this._value)); &#125; getOrElse() &#123; return this._value; &#125; filter(f) &#123; return Maybe.fromNullable(f(this._value) ? this._value : null); &#125; chain(f) &#123; return f(this._value); &#125; toString () &#123; return `Maybe.Just($&#123;this._value&#125;)`; &#125;&#125;class Nothing extends Maybe &#123; map(f) &#123; return this; &#125; get value() &#123; throw new TypeError("Can't extract the value of a Nothing."); &#125; getOrElse(other) &#123; return other; &#125; filter(f) &#123; return this._value; &#125; chain(f) &#123; return this; &#125; get isNothing() &#123; return true; &#125; toString() &#123; return 'Maybe.Nothing'; &#125;&#125;//看完上面估计你也懵了 看一下使用你就会瞬间明白Maybe.fromNullable("abc").map(r =&gt; r.toUpperCase()).getOrElse("不能为空");//-&gt; "ABC"Maybe.fromNullable(null).map(r =&gt; r.toUpperCase()).getOrElse("不能为空");//-&gt; "不能为空" Either Monad用来或的判断逻。它也有2个具体的类型：Left和Right。 Left(a)包含一个可能的错误消息或抛出的异常对象。Right(b)包含一个成功值。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394class Either &#123; constructor(value) &#123; this._value = value; &#125; get value() &#123; return this._value; &#125; static left(a) &#123; return new Left(a); &#125; static right(a) &#123; return new Right(a); &#125; static fromNullable(val) &#123; return val !== null &amp;&amp; val !== undefined ? Either.right(val) : Either.left(val); &#125; static of(a) &#123; return Either.right(a); &#125;&#125;class Left extends Either &#123; map(_) &#123; return this; // noop &#125; get value() &#123; throw new TypeError("Can't extract the value of a Left(a)."); &#125; // 提取right的值 getOrElse(other) &#123; return other; &#125; //对left操作 不对right操作 orElse(f) &#123; return f(this._value); &#125; chain(f) &#123; return this; &#125; getOrElseThrow(a) &#123; throw new Error(a); &#125; filter(f) &#123; return this; &#125; toString() &#123; return `Either.Left($&#123;this._value&#125;)`; &#125;&#125;class Right extends Either &#123; map(f) &#123; return Either.of(f(this._value)); &#125; // 提取right的值 getOrElse(other) &#123; return this._value; &#125; //对left操作 不对right操作 orElse() &#123; return this; &#125; chain(f) &#123; return f(this._value); &#125; getOrElseThrow() &#123; return this._value; &#125; filter(f) &#123; return Either.fromNullable(f(this._value) ? this._value : null); &#125; toString() &#123; return `Either.Right($&#123;this._value&#125;)`; &#125; &#125;// 看不懂吧 那就再看一个例子，给一个数字取绝对值，如果小于0那么返回它的相反数 否则返回这个数字：function isLT0(num)&#123; if(num &gt;= 0)&#123; return Either.of(num);// of其实就是right &#125; else &#123; return Either.left("小于0");// left说明是小于0的 &#125;&#125;// right的话 不会执行orElse里面的函数isLT0(1).orElse(val=&gt;Either.of(-val)).value;// 1isLT0(-1).orElse(val=&gt;Either.of(-val)).value;// 1 IO Monad用来处理不纯的函数。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class IO &#123; constructor(effect) &#123; if (!_.isFunction(effect)) &#123; throw 'IO Usage: function required'; &#125; this.effect = effect; &#125; static of(a) &#123; return new IO( () =&gt; a ); &#125; static from(fn) &#123; return new IO(fn); &#125; map(fn) &#123; var self = this; return new IO(function () &#123; return fn(self.effect()); &#125;); &#125; chain(fn) &#123; return fn(this.effect()); &#125; run() &#123; return this.effect(); &#125;&#125;// 这时你特别懵逼 同样来一个例子// read和write是不纯的函数 操作DOM了 有副作用const read = function (document, id) &#123; return function () &#123; return document.querySelector(`\#$&#123;id&#125;`).innerHTML; &#125;;&#125;;const write = function(document, id) &#123; return function(val) &#123; return document.querySelector(`\#$&#123;id&#125;`).innerHTML = val; &#125;;&#125;;// 还记得之前的应用部分吗const readDom = _.partial(read, document);const writeDom = _.partial(write, document);// 现在加入有DOM结构：&lt;div id="student-name"&gt;alonzo church&lt;/div&gt;const changeToStartCase = IO.from(readDom('student-name')). map(_.startCase). map(writeDom('student-name'));//最后执行不纯的函数 调用后DOM结构变成了：&lt;div id="student-name"&gt;Alonzo Church&lt;/div&gt;changeToStartCase.run(); 记忆化（memoization）：将函数的计算结果保存起来，如果下次传入相同的参数那么就直接返回结果。12345678910111213141516171819202122232425Function.prototype.memoized = function () &#123;// 记忆化函数 let key = JSON.stringify(arguments); this._cache = this._cache || &#123;&#125;; this._cache[key] = this._cache[key] || this.apply(this, arguments); return this._cache[key];&#125;;Function.prototype.memoize = function () &#123;// 激活记忆化 let fn = this; if (fn.length !== 1)&#123; //假设这里只记忆化一元函数 如果多元函数会有如何做呢 你可以考虑一下 return fn; &#125; return function () &#123; return fn.memoized.apply(fn, arguments); &#125;;&#125;;//使用记忆化：//定义一个斐波拉契函数const factorial = ((n) =&gt; (n === 0) ? 1 : (n * factorial(n - 1)));factorial = factorial.memoize();//激活记忆化factorial(10);//首次会计算factorial(10);//第二次直接使用计算后的值 上述斐波拉契函数使用了递归会有较高的空间使用率可以使用尾递归来优化：123const factorial = (n, current = 1) =&gt; (n === 1) ? current : factorial(n - 1, n * current); 最后我们简单的用Promise封装一下AJAX作为本篇文章的结束：12345678910111213141516171819202122232425262728293031var getJSON = function (url) &#123; return new Promise(function(resolve, reject) &#123; let req = new XMLHttpRequest(); req.responseType = 'json'; req.open('GET', url); req.onload = function() &#123; if(req.status == 200) &#123; let data = JSON.parse(req.responseText); resolve(data); &#125; else &#123; reject(new Error(req.statusText)); &#125; &#125;; req.onerror = function () &#123; if(reject) &#123; reject(new Error('IO Error')); &#125; &#125;; req.send(); &#125;); &#125;;//使用getJSON('/students').then( function(students) &#123; console.log(R.map(student =&gt; student.name, students)); &#125;, function (error) &#123; console.log(error.message); &#125;);]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>函数式编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《JavaScript数据结构与算法》读书笔记]]></title>
    <url>%2F2019%2F03%2F10%2F%E3%80%8AJavaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[这本书让我回顾了一遍大学时候学的数据结构。数据结构和算法是程序员最喜欢也是最痛苦的部分，这本书很轻松的描述了这部分东西，是一本很不错的书。这篇文章记录书中的重点部分，并不会对书中所有的内容都复述一遍，如果希望了解更多的内容可以去看看这本书。由于ES5和ES6思想基本上是相同的，这里只记录ES6的实现。 1. 栈 栈是一种遵从后进先出（LIFO）原则的有序集合。新添加的或待删除的元素都保存在栈的同一端，称作栈顶，另一端就叫栈底。在栈里，新元素都靠近栈顶，旧元素都接近栈底。 栈的实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950let Stack = (function () &#123; const items = new WeakMap(); class Stack &#123; constructor () &#123; items.set(this, []); &#125; push(element)&#123; let s = items.get(this); s.push(element); &#125; pop()&#123; let s = items.get(this); let r = s.pop(); return r; &#125; peek()&#123; let s = items.get(this); return s[s.length-1]; &#125; isEmpty()&#123; return items.get(this).length == 0; &#125; size()&#123; let s = items.get(this); return s.length; &#125; clear()&#123; items.set(this, []); &#125; print()&#123; console.log(this.toString()); &#125; toString()&#123; return items.get(this).toString(); &#125; &#125; return Stack3;&#125;)(); 应用：十进制转换成其他进制。1234567891011121314151617181920212223function baseConverter(decNumber, base = 2)&#123; var remStack = new Stack(), rem, baseString = '', digits = '0123456789ABCDEF'; while (decNumber &gt; 0)&#123; rem = Math.floor(decNumber % base); remStack.push(rem); decNumber = Math.floor(decNumber / base); &#125; while (!remStack.isEmpty())&#123; baseString += digits[remStack.pop()]; &#125; return baseString;&#125;console.log(baseConverter(100345, 2));// 11000011111111001console.log(baseConverter(100345, 8));// 303771console.log(baseConverter(100345, 16));// 187F9 2. 队列 队列是遵循FIFO（First In First Out，先进先出，也称为先来先服务）原则的一组有序的项。队列在尾部添加新元素，并从顶部移除元素。最新添加的元素必须排在队列的末尾。队列的实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849let Queue = (function () &#123; const items = new WeakMap(); class Queue &#123; constructor () &#123; items.set(this, []); &#125; enqueue(element) &#123; let q = items.get(this); q.push(element); &#125; dequeue() &#123; let q = items.get(this); let r = q.shift(); return r; &#125; front() &#123; let q = items.get(this); return q[0]; &#125; isEmpty()&#123; return items.get(this).length == 0; &#125; size()&#123; let q = items.get(this); return q.length; &#125; clear()&#123; items.set(this, []); &#125; print()&#123; console.log(this.toString()); &#125; toString()&#123; return items.get(this).toString(); &#125; &#125; return Queue;&#125;)(); 优先队列：给定一个优先级，如果新插入的元素按照优先级高低从栈顶到栈尾插入到第一个优先级比他的小元素的前面。注：这个实现中值越小优先级越高。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778let PriorityQueue = (function () &#123; class QueueElement &#123; constructor(element, priority)&#123; this.element = element; this.priority = priority; &#125; &#125; const items = new WeakMap(); class PriorityQueue &#123; //extends Queue &#123; //with this approach the private properties are not reachable through inheritance constructor () &#123; items.set(this, []); &#125; enqueue(element, priority)&#123; let queueElement = new QueueElement(element, priority); let q = items.get(this); let added = false; for (let i=0; i&lt;q.length; i++)&#123; if (queueElement.priority &lt; q[i].priority)&#123;// 如果插入的优先级比元素的优先级高 q.splice(i,0,queueElement); added = true; break; &#125; &#125; if (!added)&#123;//如果前面的优先级都比自己大那么插入到栈尾 q.push(queueElement); &#125; items.set(this, q); &#125;; dequeue() &#123; let q = items.get(this); let r = q.shift(); items.set(this, q); return r; &#125; front() &#123; let q = items.get(this); return q[0]; &#125; isEmpty()&#123; return items.get(this).length == 0; &#125; size()&#123; let q = items.get(this); return q.length; &#125; clear()&#123; items.set(this, []); &#125; print()&#123; let q = items.get(this); for (let i=0; i&lt;q.length; i++)&#123; console.log(`$&#123;q[i].element&#125; - $&#123;q[i].priority&#125;`); &#125; &#125;; &#125; return PriorityQueue;&#125;)();let priorityQueue = new PriorityQueue();priorityQueue.enqueue("John", 2);priorityQueue.enqueue("Jack", 1);priorityQueue.enqueue("Ana", 3);priorityQueue.print(); 实战：击鼓传花，使用循环队列来实现。题目描述：在这个游戏中，孩子们围成一个圆圈，把花尽快地传递给旁边的人。某一时刻传花停止，这个时候花在谁手里，谁就退出圆圈结束游戏。重复这个过程，直到只剩一个孩子（胜者）。 1234567891011121314151617181920212223function hotPotato (nameList, num)&#123; let queue = new Queue(); for (let i=0; i&lt;nameList.length; i++)&#123; queue.enqueue(nameList[i]); &#125; let eliminated = ''; while (queue.size() &gt; 1)&#123; for (let i=0; i&lt;num; i++)&#123; queue.enqueue(queue.dequeue()); &#125; eliminated = queue.dequeue(); console.log(eliminated + ' was eliminated from the Hot Potato game.'); &#125; return queue.dequeue();&#125;let names = ['John','Jack','Camila','Ingrid','Carl'];let winner = hotPotato(names, 7);console.log('The winner is: ' + winner);// The winner is: John 运行示例图： 3. 列表列表是为了解决数组插入或移除消耗内存大而出现的数据结构。链表存储有序的元素集合，但不同于数组，链表中的元素在内存中并不是连续放置的。每个元素由一个存储元素本身的节点和一个指向下一个元素的引用（也称指针或链接）组成。 列表的实现：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170let LinkedList = (function () &#123; class Node &#123; constructor(element)&#123; this.element = element; this.next = null; &#125; &#125; const length = new WeakMap(); const head = new WeakMap(); class LinkedList &#123; constructor () &#123; length.set(this, 0); head.set(this, null); &#125; append(element) &#123; let node = new Node(element), current; if (this.getHead() === null) &#123; //first node on list head.set(this, node); &#125; else &#123; current = this.getHead(); //loop the list until find last item while (current.next) &#123; current = current.next; &#125; //get last item and assign next to added item to make the link current.next = node; &#125; //update size of list let l = this.size(); l++; length.set(this, l); &#125; insert(position, element) &#123; //check for out-of-bounds values if (position &gt;= 0 &amp;&amp; position &lt;= this.size()) &#123; let node = new Node(element), current = this.getHead(), previous, index = 0; if (position === 0) &#123; //add on first position node.next = current; head.set(this, node); &#125; else &#123; while (index++ &lt; position) &#123; previous = current; current = current.next; &#125; node.next = current; previous.next = node; &#125; //update size of list let l = this.size(); l++; length.set(this, l); return true; &#125; else &#123; return false; &#125; &#125; removeAt(position) &#123; //check for out-of-bounds values if (position &gt; -1 &amp;&amp; position &lt; this.size()) &#123; let current = this.getHead(), previous, index = 0; //removing first item if (position === 0) &#123; head.set(this, current.next); &#125; else &#123; while (index++ &lt; position) &#123; previous = current; current = current.next; &#125; //link previous with current's next - skip it to remove previous.next = current.next; &#125; let l = this.size(); l--; length.set(this, l); return current.element; &#125; else &#123; return null; &#125; &#125; remove(element) &#123; let index = this.indexOf(element); return this.removeAt(index); &#125; indexOf(element) &#123; let current = this.getHead(), index = 0; while (current) &#123; if (element === current.element) &#123; return index; &#125; index++; current = current.next; &#125; return -1; &#125; isEmpty() &#123; return this.size() === 0; &#125; size() &#123; return length.get(this); &#125; getHead() &#123; return head.get(this); &#125; toString() &#123; let current = this.getHead(), string = ''; while (current) &#123; string += current.element + (current.next ? ', ' : ''); current = current.next; &#125; return string; &#125; print() &#123; console.log(this.toString()); &#125; &#125; return LinkedList;&#125;)(); 双向列表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242let DoublyLinkedList = (function () &#123; class Node &#123; constructor(element) &#123; this.element = element; this.next = null; this.prev = null; //NEW &#125; &#125; const length = new WeakMap(); const head = new WeakMap(); const tail = new WeakMap(); //NEW class DoublyLinkedList &#123; constructor () &#123; length.set(this, 0); head.set(this, null); tail.set(this, null); &#125; append(element) &#123; let node = new Node(element), current, _tail; if (this.getHead() === null) &#123; //first node on list head.set(this, node); tail.set(this, node); //NEW &#125; else &#123; //attach to the tail node //NEW _tail = this.getTail(); _tail.next = node; node.prev = _tail; tail.set(this, node); &#125; //update size of list let l = this.size(); l++; length.set(this, l); &#125; insert(position, element) &#123; //check for out-of-bounds values if (position &gt;= 0 &amp;&amp; position &lt;= this.size()) &#123; let node = new Node(element), current = this.getHead(), previous, index = 0; if (position === 0) &#123; //add on first position if (!this.getHead()) &#123; //NEW head.set(this, node); tail.set(this, node); &#125; else &#123; node.next = current; current.prev = node; //NEW &#123;1&#125; head.set(this, node); &#125; &#125; else if (position === this.size()) &#123; //last item //NEW current = tail; current.next = node; node.prev = current; tail.set(this, node); &#125; else &#123; while (index++ &lt; position) &#123; previous = current; current = current.next; &#125; node.next = current; previous.next = node; current.prev = node; //NEW node.prev = previous; //NEW &#125; //update size of list let l = this.size(); l++; length.set(this, l); return true; &#125; else &#123; return false; &#125; &#125; removeAt(position) &#123; //check for out-of-bounds values if (position &gt; -1 &amp;&amp; position &lt; this.size()) &#123; let _head = this.getHead(), _tail = this.getTail(), current = _head, previous, index = 0; //removing first item if (position === 0) &#123; _head = current.next; //if there is only one item, then we update tail as well //NEW if (this.size() === 1) &#123; _tail = null; &#125; else &#123; _head.prev = null; &#125; &#125; else if (position === this.size() - 1) &#123; //last item //NEW current = _tail; _tail = current.prev; _tail.next = null; &#125; else &#123; while (index++ &lt; position) &#123; previous = current; current = current.next; &#125; //link previous with current's next - skip it to remove previous.next = current.next; current.next.prev = previous; //NEW &#125; head.set(this,_head); tail.set(this,_tail); //update size of list let l = this.size(); l--; length.set(this, l); return current.element; &#125; else &#123; return null; &#125; &#125; remove(element) &#123; let index = this.indexOf(element); return this.removeAt(index); &#125; indexOf(element) &#123; let current = this.getHead(), index = -1; //check first item if (element == current.element) &#123; return 0; &#125; index++; //check in the middle of the list while (current.next) &#123; if (element == current.element) &#123; return index; &#125; current = current.next; index++; &#125; //check last item if (element == current.element) &#123; return index; &#125; return -1; &#125; isEmpty() &#123; return this.size() === 0; &#125; size() &#123; return length.get(this); &#125; toString() &#123; let current = this.getHead(), s = current ? current.element : ''; while (current &amp;&amp; current.next) &#123; current = current.next; s += ', ' + current.element; &#125; return s; &#125; inverseToString() &#123; let current = this.getTail(), s = current ? current.element : ''; while (current &amp;&amp; current.prev) &#123; current = current.prev; s += ', ' + current.element; &#125; return s; &#125; print() &#123; console.log(this.toString()); &#125; printInverse() &#123; console.log(this.inverseToString()); &#125; getHead() &#123; return head.get(this); &#125; getTail() &#123; return tail.get(this); &#125; &#125; return DoublyLinkedList;&#125;)(); 4. 集合集合是由一组无序且唯一（即不能重复）的项组成的。这个数据结构使用了与有限集合相同的数学概念，但应用在计算机科学的数据结构中。注：这里的名称叫Set但是最好不要用这个名字，因为ES6中本来就有这个全局变量。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119let Set = (function () &#123; const items = new WeakMap(); class Set &#123; constructor () &#123; items.set(this, &#123;&#125;); &#125; add(value)&#123; if (!this.has(value))&#123; let items_ = items.get(this); items_[value] = value;// [键，键]形式 return true; &#125; return false; &#125; delete(value)&#123; if (this.has(value))&#123; let items_ = items.get(this); delete items_[value]; return true; &#125; return false; &#125; has(value)&#123; let items_ = items.get(this); return items_.hasOwnProperty(value); &#125; clear()&#123; items.set(this, &#123;&#125;); &#125; size()&#123; let items_ = items.get(this); return Object.keys(items_).length; &#125; values()&#123; let values = []; let items_ = items.get(this); for (let i=0, keys=Object.keys(items_); i&lt;keys.length; i++) &#123; values.push(items_[keys[i]]); &#125; return values; &#125; getItems()&#123; return items.get(this); &#125; //并集 A合B的全部元素 union(otherSet)&#123; let unionSet = new Set(); let values = this.values(); for (let i=0; i&lt;values.length; i++)&#123; unionSet.add(values[i]); &#125; values = otherSet.values(); for (let i=0; i&lt;values.length; i++)&#123; unionSet.add(values[i]); &#125; return unionSet; &#125; // 交集 A和B公共的部分 intersection(otherSet)&#123; let intersectionSet = new Set(); let values = this.values(); for (let i=0; i&lt;values.length; i++)&#123; if (otherSet.has(values[i]))&#123; intersectionSet.add(values[i]); &#125; &#125; return intersectionSet; &#125; // 差集 A去过B的部分 difference(otherSet)&#123; let differenceSet = new Set(); let values = this.values(); for (let i=0; i&lt;values.length; i++)&#123; if (!otherSet.has(values[i]))&#123; differenceSet.add(values[i]); &#125; &#125; return differenceSet; &#125;; // 子集 B是否包含A subset(otherSet)&#123; if (this.size() &gt; otherSet.size())&#123; return false; &#125; else &#123; let values = this.values(); for (let i=0; i&lt;values.length; i++)&#123; if (!otherSet.has(values[i]))&#123; return false; &#125; &#125; return true; &#125; &#125;; &#125; return Set;&#125;)(); 5. 字典在字典中，存储的是[键，值]对（其实就是我们的Map），其中键名是用来查询特定元素的。字典和集合很相似，集合以[值，值]的形式存储元素，字典则是以[键，值]的形式来存储元素。字典也称作映射。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859function Dictionary()&#123; var items = &#123;&#125;; this.set = function(key, value)&#123; items[key] = value; &#125;; this.delete = function(key)&#123; if (this.has(key))&#123; delete items[key]; return true; &#125; return false; &#125;; this.has = function(key)&#123; return items.hasOwnProperty(key); //return value in items; &#125;; this.get = function(key) &#123; return this.has(key) ? items[key] : undefined; &#125;; this.clear = function()&#123; items = &#123;&#125;; &#125;; this.size = function()&#123; return Object.keys(items).length; &#125;; this.keys = function()&#123; return Object.keys(items); &#125;; this.values = function()&#123; var values = []; for (var k in items) &#123; if (this.has(k)) &#123; values.push(items[k]); &#125; &#125; return values; &#125;; this.each = function(fn) &#123; for (var k in items) &#123; if (this.has(k)) &#123; fn(k, items[k]); &#125; &#125; &#125;; this.getItems = function()&#123; return items; &#125;&#125; 6. 散列表散列表是散列值（HashCode）和真实值的对应关系，为了避免多个值对应相同HashCode的情况，在存储的时候会存在HashCode所在位置及以后第一个不为空的地方，查找的时候找到hashCode所处的位置，然后从这里开始向后找，知道找到键相同的元素。也可以使用之前开发好的LinkedList和HashCode的对应关系避免。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293function HashTable()&#123; var table = []; var ValuePair = function(key, value)&#123; this.key = key; this.value = value; this.toString = function() &#123; return '[' + this.key + ' - ' + this.value + ']'; &#125; &#125;; var loseloseHashCode = function (key) &#123; var hash = 0; for (var i = 0; i &lt; key.length; i++) &#123; hash += key.charCodeAt(i); &#125; return hash % 37; &#125;; var djb2HashCode = function (key) &#123; var hash = 5381; for (var i = 0; i &lt; key.length; i++) &#123; hash = hash * 33 + key.charCodeAt(i); &#125; return hash % 1013; &#125;; var hashCode = function(key)&#123; return loseloseHashCode(key); // 这里也可以使用djb2HashCode来生成hash值 &#125;; this.put = function(key, value)&#123; var position = hashCode(key); console.log(position + ' - ' + key); if (table[position] == undefined) &#123; table[position] = new ValuePair(key, value); &#125; else &#123; var index = ++position; while (table[index] != undefined)&#123; index++; &#125; table[index] = new ValuePair(key, value); &#125; &#125;; this.get = function(key) &#123; var position = hashCode(key); if (table[position] !== undefined)&#123; if (table[position].key === key) &#123; return table[position].value; &#125; else &#123; var index = ++position; while (table[index] === undefined || table[index].key !== key)&#123; index++; &#125; if (table[index].key === key) &#123; return table[index].value; &#125; &#125; &#125; return undefined; &#125;; this.remove = function(key)&#123; var position = hashCode(key); if (table[position] !== undefined)&#123; if (table[position].key === key) &#123; table[position] = undefined; &#125; else &#123; var index = ++position; while (table[index] === undefined || table[index].key !== key)&#123; index++; &#125; if (table[index].key === key) &#123; table[index] = undefined; &#125; &#125; &#125; &#125;; this.print = function() &#123; for (var i = 0; i &lt; table.length; ++i) &#123; if (table[i] !== undefined) &#123; console.log(i + ' -&gt; ' + table[i].toString()); &#125; &#125; &#125;;&#125; 7. 树一个树结构包含一系列存在父子关系的节点。每个节点都有一个父节点（除了顶部的第一个节点）以及零个或多个子节点。 位于树顶部的节点叫作根节点（11）。它没有父节点。树中的每个元素都叫作节点，节点分为内部节点和外部节点。至少有一个子节点的节点称为内部节点（7、5、9、15、13和20是内部节点）。没有子元素的节点称为外部节点或叶节点（3、6、8、10、12、14、18和25是叶节点）。 一个节点可以有祖先和后代。一个节点（除了根节点）的祖先包括父节点、祖父节点、曾祖父节点等。一个节点的后代包括子节点、孙子节点、曾孙节点等。 二叉树中的节点最多只能有两个子节点：一个是左侧子节点，另一个是右侧子节点。这些定义有助于我们写出更高效的向/从树中插入、查找和删除节点的算法。二叉树在计算机科学中的应用非常广泛。 二叉搜索树（BST）是二叉树的一种，但是它只允许你在左侧节点存储（比父节点）小的值，在右侧节点存储（比父节点）大（或者等于）的值。 二叉搜索树的实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192function BinarySearchTree() &#123; var Node = function(key)&#123; this.key = key; this.left = null; this.right = null; &#125;; var root = null; this.insert = function(key)&#123; var newNode = new Node(key); //special case - first element if (root === null)&#123; root = newNode; &#125; else &#123; insertNode(root,newNode); &#125; &#125;; var insertNode = function(node, newNode)&#123; if (newNode.key &lt; node.key)&#123; if (node.left === null)&#123; node.left = newNode; &#125; else &#123; insertNode(node.left, newNode); &#125; &#125; else &#123; if (node.right === null)&#123; node.right = newNode; &#125; else &#123; insertNode(node.right, newNode); &#125; &#125; &#125;; this.getRoot = function()&#123; return root; &#125;; this.search = function(key)&#123; return searchNode(root, key); &#125;; var searchNode = function(node, key)&#123; if (node === null)&#123; return false; &#125; if (key &lt; node.key)&#123; return searchNode(node.left, key); &#125; else if (key &gt; node.key)&#123; return searchNode(node.right, key); &#125; else &#123; //element is equal to node.item return true; &#125; &#125;; //中序遍历 前-&gt;中-&gt;后 this.inOrderTraverse = function(callback)&#123; inOrderTraverseNode(root, callback); &#125;; var inOrderTraverseNode = function (node, callback) &#123; if (node !== null) &#123; inOrderTraverseNode(node.left, callback); callback(node.key); inOrderTraverseNode(node.right, callback); &#125; &#125;; //前序遍历 中-&gt;前-&gt;后 this.preOrderTraverse = function(callback)&#123; preOrderTraverseNode(root, callback); &#125;; var preOrderTraverseNode = function (node, callback) &#123; if (node !== null) &#123; callback(node.key); preOrderTraverseNode(node.left, callback); preOrderTraverseNode(node.right, callback); &#125; &#125;; //后序遍历 前-&gt;后-&gt;中 this.postOrderTraverse = function(callback)&#123; postOrderTraverseNode(root, callback); &#125;; var postOrderTraverseNode = function (node, callback) &#123; if (node !== null) &#123; postOrderTraverseNode(node.left, callback); postOrderTraverseNode(node.right, callback); callback(node.key); &#125; &#125;; // 最小值 最左边的点 this.min = function() &#123; return minNode(root); &#125;; var minNode = function (node) &#123; if (node)&#123; while (node &amp;&amp; node.left !== null) &#123; node = node.left; &#125; return node.key; &#125; return null; &#125;; // 最小值 最右边的点 this.max = function() &#123; return maxNode(root); &#125;; var maxNode = function (node) &#123; if (node)&#123; while (node &amp;&amp; node.right !== null) &#123; node = node.right; &#125; return node.key; &#125; return null; &#125;; this.remove = function(element)&#123; root = removeNode(root, element); &#125;; var findMinNode = function(node)&#123; while (node &amp;&amp; node.left !== null) &#123; node = node.left; &#125; return node; &#125;; var removeNode = function(node, element)&#123; if (node === null)&#123; return null; &#125; if (element &lt; node.key)&#123; node.left = removeNode(node.left, element); return node; &#125; else if (element &gt; node.key)&#123; node.right = removeNode(node.right, element); return node; &#125; else &#123; //element is equal to node.item //handle 3 special conditions //1 - a leaf node //2 - a node with only 1 child //3 - a node with 2 children //case 1 if (node.left === null &amp;&amp; node.right === null)&#123; node = null; return node; &#125; //case 2 if (node.left === null)&#123; node = node.right; return node; &#125; else if (node.right === null)&#123; node = node.left; return node; &#125; //case 3 var aux = findMinNode(node.right); node.key = aux.key; node.right = removeNode(node.right, aux.key); return node; &#125; &#125;;&#125; AVL树BST（二叉搜索树）存在一个问题：取决于你添加的节点数，树的一条边可能会非常深；也就是说，树的一条分支会有很多层，而其他的分支却只有几层。就比如如果第一次添加的是1（根节点），其他节点添加的都是大于1的数，那么其他的节点都会在根节点的右边而左边就没有左子树了。这种情况下添加、移除和搜索某个节点时引起一些性能问题。为了解决这个问题，有一种树叫作Adelson-Velskii-Landi树（AVL树）。AVL树是一种自平衡二叉搜索树，意思是任何一个节点左右两侧子树的高度之差最多为1。也就是说这种树会在添加或移除节点时尽量试着成为一棵完全树。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149function AVLTree() &#123; var Node = function(key)&#123; this.key = key; this.left = null; this.right = null; &#125;; var root = null; this.getRoot = function()&#123; return root; &#125;; var heightNode = function(node) &#123; if (node === null) &#123; return -1; &#125; else &#123; return Math.max(heightNode(node.left), heightNode(node.right)) + 1; &#125; &#125;; var rotationLL = function(node) &#123; var tmp = node.left; node.left = tmp.right; tmp.right = node; return tmp; &#125;; var rotationRR = function(node) &#123; var tmp = node.right; node.right = tmp.left; tmp.left = node; return tmp; &#125;; var rotationLR = function(node) &#123; node.left = rotationRR(node.left); return rotationLL(node); &#125;; var rotationRL = function(node) &#123; node.right = rotationLL(node.right); return rotationRR(node); &#125;; var insertNode = function(node, element) &#123; if (node === null) &#123; node = new Node(element); &#125; else if (element &lt; node.key) &#123; node.left = insertNode(node.left, element); if (node.left !== null) &#123; if ((heightNode(node.left) - heightNode(node.right)) &gt; 1)&#123; if (element &lt; node.left.key)&#123; node = rotationLL(node); &#125; else &#123; node = rotationLR(node); &#125; &#125; &#125; &#125; else if (element &gt; node.key) &#123; node.right = insertNode(node.right, element); if (node.right !== null) &#123; if ((heightNode(node.right) - heightNode(node.left)) &gt; 1)&#123; if (element &gt; node.right.key)&#123; node = rotationRR(node); &#125; else &#123; node = rotationRL(node); &#125; &#125; &#125; &#125; return node; &#125;; this.insert = function(element) &#123; root = insertNode(root, element); &#125;; var parentNode; var nodeToBeDeleted; var removeNode = function(node, element) &#123; if (node === null) &#123; return null; &#125; parentNode = node; if (element &lt; node.key) &#123; node.left = removeNode(node.left, element); &#125; else &#123; nodeToBeDeleted = node; node.right = removeNode(node.right, element); &#125; if (node === parentNode) &#123; //remove node if (nodeToBeDeleted !== null &amp;&amp; element === nodeToBeDeleted.key) &#123; if (nodeToBeDeleted === parentNode) &#123; node = node.left; &#125; else &#123; var tmp = nodeToBeDeleted.key; nodeToBeDeleted.key = parentNode.key; parentNode.key = tmp; node = node.right; &#125; &#125; &#125; else &#123; //do balancing if (node.left === undefined) node.left = null; if (node.right === undefined) node.right = null; if ((heightNode(node.left) - heightNode(node.right)) === 2) &#123; if (element &lt; node.left.key) &#123; node = rotationLR(node); &#125; else &#123; node = rotationLL(node); &#125; &#125; if ((heightNode(node.right) - heightNode(node.left)) === 2) &#123; if (element &gt; node.right.key) &#123; node = rotationRL(node); &#125; else &#123; node = rotationRR(node); &#125; &#125; &#125; return node; &#125;; this.remove = function(element) &#123; parentNode = null; nodeToBeDeleted = null; root = removeNode(root, element); &#125;;&#125; 红黑树的实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101function RedBlackTree() &#123; var Colors = &#123; RED: 0, BLACK: 1 &#125;; var Node = function (key, color) &#123; this.key = key; this.left = null; this.right = null; this.color = color; this.flipColor = function()&#123; if (this.color === Colors.RED) &#123; this.color = Colors.BLACK; &#125; else &#123; this.color = Colors.RED; &#125; &#125;; &#125;; var root = null; this.getRoot = function () &#123; return root; &#125;; var isRed = function(node)&#123; if (!node)&#123; return false; &#125; return node.color === Colors.RED; &#125;; var flipColors = function(node)&#123; node.left.flipColor(); node.right.flipColor(); &#125;; var rotateLeft = function(node)&#123; var temp = node.right; if (temp !== null) &#123; node.right = temp.left; temp.left = node; temp.color = node.color; node.color = Colors.RED; &#125; return temp; &#125;; var rotateRight = function (node) &#123; var temp = node.left; if (temp !== null) &#123; node.left = temp.right; temp.right = node; temp.color = node.color; node.color = Colors.RED; &#125; return temp; &#125;; var insertNode = function(node, element) &#123; if (node === null) &#123; return new Node(element, Colors.RED); &#125; var newRoot = node; if (element &lt; node.key) &#123; node.left = insertNode(node.left, element); &#125; else if (element &gt; node.key) &#123; node.right = insertNode(node.right, element); &#125; else &#123; node.key = element; &#125; if (isRed(node.right) &amp;&amp; !isRed(node.left)) &#123; newRoot = rotateLeft(node); &#125; if (isRed(node.left) &amp;&amp; isRed(node.left.left)) &#123; newRoot = rotateRight(node); &#125; if (isRed(node.left) &amp;&amp; isRed(node.right)) &#123; flipColors(node); &#125; return newRoot; &#125;; this.insert = function(element) &#123; root = insertNode(root, element); root.color = Colors.BLACK; &#125;;&#125; 8. 图图是网络结构的抽象模型。图是一组由边连接的节点（或顶点）。学习图是重要的，因为任何二元关系都可以用图来表示。一个图G = (V, E)由以下元素组成。 V：一组顶点E：一组边，连接V中的顶点 由一条边连接在一起的顶点称为相邻顶点。一个顶点的度是其相邻顶点的数量。如果图中不存在环，则称该图是无环的。如果图中每两个顶点间都存在路径，则该图是连通的。图可以分为是无向图（边没有方向）和有向图（有向图）。图也可以是未加权的（目前为止我们看到的图都是未加权的）或是加权的。 图有的三种表示法8.1.1 邻接矩阵 8.1.2 邻接表 8.1.3 关联矩阵 图的遍历有两种：8.2.1 广度优先搜索： 8.2.2 深度优先搜索： 图的实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173function Graph() &#123; var vertices = []; //list var adjList = new Dictionary(); this.addVertex = function(v)&#123; vertices.push(v); adjList.set(v, []); //initialize adjacency list with array as well; &#125;; this.addEdge = function(v, w)&#123; adjList.get(v).push(w); //adjList.get(w).push(v); //commented to run the improved DFS with topological sorting &#125;; this.toString = function()&#123; var s = ''; for (var i=0; i&lt;vertices.length; i++)&#123; s += vertices[i] + ' -&gt; '; var neighbors = adjList.get(vertices[i]); for (var j=0; j&lt;neighbors.length; j++)&#123; s += neighbors[j] + ' '; &#125; s += '\n'; &#125; return s; &#125;; var initializeColor = function()&#123; var color = &#123;&#125;; for (var i=0; i&lt;vertices.length; i++)&#123; color[vertices[i]] = 'white'; &#125; return color; &#125;; this.bfs = function(v, callback)&#123; var color = initializeColor(), queue = new Queue(); queue.enqueue(v); while (!queue.isEmpty())&#123; var u = queue.dequeue(), neighbors = adjList.get(u); color[u] = 'grey'; for (var i=0; i&lt;neighbors.length; i++)&#123; var w = neighbors[i]; if (color[w] === 'white')&#123; color[w] = 'grey'; queue.enqueue(w); &#125; &#125; color[u] = 'black'; if (callback) &#123; callback(u); &#125; &#125; &#125;; this.dfs = function(callback)&#123; var color = initializeColor(); for (var i=0; i&lt;vertices.length; i++)&#123; if (color[vertices[i]] === 'white')&#123; dfsVisit(vertices[i], color, callback); &#125; &#125; &#125;; var dfsVisit = function(u, color, callback)&#123; color[u] = 'grey'; if (callback) &#123; callback(u); &#125; console.log('Discovered ' + u); var neighbors = adjList.get(u); for (var i=0; i&lt;neighbors.length; i++)&#123; var w = neighbors[i]; if (color[w] === 'white')&#123; dfsVisit(w, color, callback); &#125; &#125; color[u] = 'black'; console.log('explored ' + u); &#125;; // 广度优先搜索（Breadth-First Search，BFS） this.BFS = function(v)&#123; var color = initializeColor(), queue = new Queue(), d = &#123;&#125;, pred = &#123;&#125;; queue.enqueue(v); for (var i=0; i&lt;vertices.length; i++)&#123; d[vertices[i]] = 0; pred[vertices[i]] = null; &#125; while (!queue.isEmpty())&#123; var u = queue.dequeue(), neighbors = adjList.get(u); color[u] = 'grey'; for (i=0; i&lt;neighbors.length; i++)&#123; var w = neighbors[i]; if (color[w] === 'white')&#123; color[w] = 'grey'; d[w] = d[u] + 1; pred[w] = u; queue.enqueue(w); &#125; &#125; color[u] = 'black'; &#125; return &#123; distances: d, predecessors: pred &#125;; &#125;; //深度优先搜索（Depth-First Search，DFS） var time = 0; this.DFS = function()&#123; var color = initializeColor(), d = &#123;&#125;, f = &#123;&#125;, p = &#123;&#125;; time = 0; for (var i=0; i&lt;vertices.length; i++)&#123; f[vertices[i]] = 0; d[vertices[i]] = 0; p[vertices[i]] = null; &#125; for (i=0; i&lt;vertices.length; i++)&#123; if (color[vertices[i]] === 'white')&#123; DFSVisit(vertices[i], color, d, f, p); &#125; &#125; return &#123; discovery: d, finished: f, predecessors: p &#125;; &#125;; var DFSVisit = function(u, color, d, f, p)&#123; console.log('discovered ' + u); color[u] = 'grey'; d[u] = ++time; var neighbors = adjList.get(u); for (var i=0; i&lt;neighbors.length; i++)&#123; var w = neighbors[i]; if (color[w] === 'white')&#123; p[w] = u; DFSVisit(w,color, d, f, p); &#125; &#125; color[u] = 'black'; f[u] = ++time; console.log('explored ' + u); &#125;;&#125; 9. 排序和查找 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426function ArrayList()&#123; var array = []; this.insert = function(item)&#123; array.push(item); &#125;; var swap = function(array, index1, index2)&#123; var aux = array[index1]; array[index1] = array[index2]; array[index2] = aux; //ES2015 swap - Firefox only, for other browser, uncomment code above and coment line below //[array[index1], array[index2]] = [array[index2], array[index1]]; &#125;; this.toString= function()&#123; return array.join(); &#125;; this.array= function()&#123; return array; &#125;; // 冒泡排序 this.bubbleSort = function()&#123; var length = array.length; for (var i=0; i&lt;length; i++)&#123; console.log('--- '); for (var j=0; j&lt;length-1; j++ )&#123; console.log('compare ' + array[j] + ' with ' + array[j+1]); if (array[j] &gt; array[j+1])&#123; console.log('swap ' + array[j] + ' with ' + array[j+1]); swap(array, j, j+1); &#125; &#125; &#125; &#125;; // 稍微改进一点的冒泡排序 （还可以加标示位来改进） this.modifiedBubbleSort = function()&#123; var length = array.length; for (var i=0; i&lt;length; i++)&#123; console.log('--- '); for (var j=0; j&lt;length-1-i; j++ )&#123; console.log('compare ' + array[j] + ' with ' + array[j+1]); if (array[j] &gt; array[j+1])&#123; console.log('swap ' + array[j] + ' with ' + array[j+1]); swap(j, j+1); &#125; &#125; &#125; &#125;; // 选择排序：每次寻找数据结构中的最小值放在未排序结构的前面 this.selectionSort = function()&#123; var length = array.length, indexMin; for (var i=0; i&lt;length-1; i++)&#123; indexMin = i; console.log('index ' + array[i]); for (var j=i; j&lt;length; j++)&#123; if(array[indexMin]&gt;array[j])&#123; console.log('new index min ' + array[j]); indexMin = j; &#125; &#125; if (i !== indexMin)&#123; console.log('swap ' + array[i] + ' with ' + array[indexMin]); swap(i, indexMin); &#125; &#125; &#125;; // 插入排序：元素插入到已排序的元素中 this.insertionSort = function()&#123; var length = array.length, j, temp; for (var i=1; i&lt;length; i++)&#123; j = i; temp = array[i]; console.log('to be inserted ' + temp); while (j&gt;0 &amp;&amp; array[j-1] &gt; temp)&#123; console.log('shift ' + array[j-1]); array[j] = array[j-1]; j--; &#125; console.log('insert ' + temp); array[j] = temp; &#125; &#125;; var insertionSort_ = function(array)&#123; var length = array.length, j, temp; for (var i=1; i&lt;length; i++)&#123; j = i; temp = array[i]; while (j&gt;0 &amp;&amp; array[j-1] &gt; temp)&#123; array[j] = array[j-1]; j--; &#125; array[j] = temp; &#125; &#125;; //归并排序 this.mergeSort = function()&#123; array = mergeSortRec(array); &#125;; var mergeSortRec = function(array)&#123; var length = array.length; if(length === 1) &#123; console.log(array); return array; &#125; var mid = Math.floor(length / 2), left = array.slice(0, mid), right = array.slice(mid, length); return merge(mergeSortRec(left), mergeSortRec(right)); &#125;; var merge = function(left, right)&#123; var result = [], il = 0, ir = 0; while(il &lt; left.length &amp;&amp; ir &lt; right.length) &#123; if(left[il] &lt; right[ir]) &#123; result.push(left[il++]); &#125; else&#123; result.push(right[ir++]); &#125; &#125; while (il &lt; left.length)&#123; result.push(left[il++]); &#125; while (ir &lt; right.length)&#123; result.push(right[ir++]); &#125; console.log(result); return result; &#125;; //快速排序 this.quickSort = function()&#123; quick(array, 0, array.length - 1); &#125;; var partition = function(array, left, right) &#123; var pivot = array[Math.floor((right + left) / 2)], i = left, j = right; console.log('pivot is ' + pivot + '; left is ' + left + '; right is ' + right); while (i &lt;= j) &#123; while (array[i] &lt; pivot) &#123; i++; console.log('i = ' + i); &#125; while (array[j] &gt; pivot) &#123; j--; console.log('j = ' + j); &#125; if (i &lt;= j) &#123; console.log('swap ' + array[i] + ' with ' + array[j]); swap(array, i, j); i++; j--; &#125; &#125; return i; &#125;; var quick = function(array, left, right)&#123; var index; if (array.length &gt; 1) &#123; index = partition(array, left, right); if (left &lt; index - 1) &#123; quick(array, left, index - 1); &#125; if (index &lt; right) &#123; quick(array, index, right); &#125; &#125; return array; &#125;; //堆排序 this.heapSort = function()&#123; var heapSize = array.length; buildHeap(array); while (heapSize &gt; 1) &#123; heapSize--; console.log('swap (' + + array[0] + ',' + array[heapSize] + ')'); swap(array, 0, heapSize); console.log('heapify ' + array.join()); heapify(array, heapSize, 0); &#125; &#125;; var buildHeap = function(array)&#123; console.log('building heap'); var heapSize = array.length; for (var i = Math.floor(array.length / 2); i &gt;= 0; i--) &#123; heapify(array, heapSize, i); &#125; console.log('heap created: ' + array.join()); &#125;; var heapify = function(array, heapSize, i)&#123; var left = i * 2 + 1, right = i * 2 + 2, largest = i; if (left &lt; heapSize &amp;&amp; array[left] &gt; array[largest]) &#123; largest = left; &#125; if (right &lt; heapSize &amp;&amp; array[right] &gt; array[largest]) &#123; largest = right; &#125; console.log('Heapify Index = '+ i + ' and Heap Size = ' + heapSize); if (largest !== i) &#123; console.log('swap index ' + i + ' with ' + largest + ' (' + + array[i] + ',' + array[largest] + ')'); swap(array, i, largest); console.log('heapify ' + array.join()); heapify(array, heapSize, largest); &#125; &#125;; this.countingSort = function()&#123; var i, maxValue = this.findMaxValue(), sortedIndex = 0, counts = new Array(maxValue + 1); for (i = 0; i &lt; array.length; i++) &#123; if (!counts[array[i]]) &#123; counts[array[i]] = 0; &#125; counts[array[i]]++; &#125; console.log('Frequencies: ' + counts.join()); for (i = 0; i &lt; counts.length; i++) &#123; while (counts[i] &gt; 0) &#123; array[sortedIndex++] = i; counts[i]--; &#125; &#125; &#125;; this.bucketSort = function(bucketSize)&#123; var i, minValue = this.findMinValue(), maxValue = this.findMaxValue(), BUCKET_SIZE = 5; console.log('minValue ' + minValue); console.log('maxValue ' + maxValue); bucketSize = bucketSize || BUCKET_SIZE; var bucketCount = Math.floor((maxValue - minValue) / bucketSize) + 1; var buckets = new Array(bucketCount); console.log('bucketSize = ' + bucketCount); for (i = 0; i &lt; buckets.length; i++) &#123; buckets[i] = []; &#125; for (i = 0; i &lt; array.length; i++) &#123; buckets[Math.floor((array[i] - minValue) / bucketSize)].push(array[i]); console.log('pushing item ' + array[i] + ' to bucket index ' + Math.floor((array[i] - minValue) / bucketSize)); &#125; array = []; for (i = 0; i &lt; buckets.length; i++) &#123; insertionSort_(buckets[i]); console.log('bucket sorted ' + i + ': ' + buckets[i].join()); for (var j = 0; j &lt; buckets[i].length; j++) &#123; array.push(buckets[i][j]); &#125; &#125; &#125;; this.radixSort = function(radixBase)&#123; var i, minValue = this.findMinValue(), maxValue = this.findMaxValue(), radixBase = radixBase || 10; // Perform counting sort for each significant digit), starting at 1 var significantDigit = 1; while (((maxValue - minValue) / significantDigit) &gt;= 1) &#123; console.log('radix sort for digit ' + significantDigit); array = countingSortForRadix(array, radixBase, significantDigit, minValue); console.log(array.join()); significantDigit *= radixBase; &#125; &#125;; var countingSortForRadix = function(array, radixBase, significantDigit, minValue)&#123; var i, countsIndex, counts = new Array(radixBase), aux = new Array(radixBase); for (i = 0; i &lt; radixBase; i++) &#123; counts[i] = 0; &#125; for (i = 0; i &lt; array.length; i++) &#123; countsIndex = Math.floor(((array[i] - minValue) / significantDigit) % radixBase); counts[countsIndex]++; &#125; for (i = 1; i &lt; radixBase; i++) &#123; counts[i] += counts[i - 1]; &#125; for (i = array.length - 1; i &gt;= 0; i--) &#123; countsIndex = Math.floor(((array[i] - minValue) / significantDigit) % radixBase); aux[--counts[countsIndex]] = array[i]; &#125; for (i = 0; i &lt; array.length; i++) &#123; array[i] = aux[i]; &#125; return array; &#125;; // 线性查找 this.sequentialSearch = function(item)&#123; for (var i=0; i&lt;array.length; i++)&#123; if (item === array[i])&#123; return i; &#125; &#125; return -1; &#125;; this.findMaxValue = function()&#123; var max = array[0]; for (var i=1; i&lt;array.length; i++)&#123; if (max &lt; array[i])&#123; max = array[i]; &#125; &#125; return max; &#125;; this.findMinValue = function()&#123; var min = array[0]; for (var i=1; i&lt;array.length; i++)&#123; if (min &gt; array[i])&#123; min = array[i]; &#125; &#125; return min; &#125;; //二分查找 this.binarySearch = function(item)&#123; this.quickSort(); var low = 0, high = array.length - 1, mid, element; while (low &lt;= high)&#123; mid = Math.floor((low + high) / 2); element = array[mid]; console.log('mid element is ' + element); if (element &lt; item) &#123; low = mid + 1; console.log('low is ' + low); &#125; else if (element &gt; item) &#123; high = mid - 1; console.log('high is ' + high); &#125; else &#123; console.log('found it'); return mid; &#125; &#125; return -1; &#125;;&#125; 9. 算法模式 递归实现斐波那契函数123456function fibonacci(num)&#123; if (num === 1 || num === 2)&#123; return 1; &#125; return fibonacci(num - 1) + fibonacci(num - 2);&#125; 最少硬币找零问题 动态规划求解：123456789101112131415161718192021222324252627function MinCoinChange(coins)&#123; var coins = coins; var cache = &#123;&#125;; this.makeChange = function(amount) &#123; var me = this; if (!amount) &#123; return []; &#125; if (cache[amount]) &#123; return cache[amount]; &#125; var min = [], newMin, newAmount; for (var i=0; i&lt;coins.length; i++)&#123; var coin = coins[i]; newAmount = amount - coin; if (newAmount &gt;= 0)&#123; newMin = me.makeChange(newAmount); &#125; if (newAmount &gt;= 0 &amp;&amp; (newMin.length &lt; min.length-1 || !min.length) &amp;&amp; (newMin.length || !newAmount) &#123; min = [coin].concat(newMin); console.log('new Min ' + min + ' for ' + amount); &#125; &#125; return (cache[amount] = min); &#125;;&#125; 贪心算法求解：123456789101112131415function MinCoinChange(coins)&#123; var coins = coins; this.makeChange = function(amount) &#123; var change = [], total = 0; for (var i=coins.length; i&gt;=0; i--)&#123; var coin = coins[i]; while (total + coin &lt;= amount) &#123; change.push(coin); total += coin; &#125; &#125; return change; &#125;;&#125; 使用12var minCoinChange = new MinCoinChange([1, 5, 10, 25]);console.log(minCoinChange.makeChange(36));]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>JavaScript</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES5中的继承]]></title>
    <url>%2F2019%2F03%2F04%2FES5%E4%B8%AD%E7%9A%84%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[面向对象的三大特性是：封装、继承、多态。其中继承是最难理解的，也是最重要的部分。JS中本身没有专门继承的语法，它是使用各种代码的模拟来实现的。即使ES6有了正真的继承语法，其本质也是ES5中继承的语法糖。目前ES5继承最被人津津乐道的就是尼古拉斯的著名书籍《JavaScript高级程序设计》中记录的6中方法。本文也是摘自这本本书的这部分的核心内容，并整理给大家呈现出来。 原型链继承 原型链继承是最为经典的一种继承，其继承方式就是子类的原型指向父类的实例。下面我们来看一个这种继承的例子： 1234567891011121314151617function Person(name)&#123; this.name = name; this.hobbies = ["coding","running"];&#125;Person.prototype.sayName = function()&#123; console.log("我是：" + this.name);&#125;;function Man(name)&#123; this.name = name;&#125;Man.prototype = new Person();//原型继承var lufei = new Man("海贼王的男人");lufei.sayName();// 我是：海贼王的男人 我们可以看到子类的对象lufei已经拥有父类的方法，说明继承成功了。上面最重要的一行代码是第14行，印证了子类的原型指向父类的实例。原型继承其实就是利用原型链来实现的，如果在子类中没有找到某个属性和方法就会去子类的原型中去找，如果父类的实例没有又会去父类的原型去找，直到找到Object的原型为止。 原型继承是最简单最长用的一种继承方式，但是它有自己的缺点： 缺点1：父类中引用类型的属性，会被子类共享。 如上例中的hobbies属性，每个子类的实例都指向了同一个hobbies属性。如果某个子类不重写hobbies并且给他添加了一个值，那么所有的没有重写hobbies的子类的这个值都将会改变（同一个对象）。缺点2：创建子类的时候，无法调用父元素的构造函数。 如上例中的this.name = name;在父类中已有相同的代码无法做到复用。 借用构造函数实现继承 借用构造函数实现的继承是解决原型继承的缺点而出现的，他的核心思想就是子类通过call（或者apply）调用父类的构造函数。请看下面的例子： 1234567891011121314function Person()&#123; this.hobbies = ["coding","running"];&#125;function Man()&#123; Person.call(this); // 借用构造函数的继承&#125;var lufei = new Man();var nami = new Man();lufei.hobbies.push("eat meat");console.log(lufei.hobbies); // ["coding", "running", "eat meat"]console.log(nami.hobbies); // ["coding", "running"] 右上可知，子类的两个对象lufei和nami都拥有了父类的属性，所以继承成功。我们可以看到子类可以调用父类的构造方法，同时父类的引用属性也不再共享。 这种方法的缺点： 缺点1：父类原型中的属性和方法无法继承。缺点2：对每个子类对象来说，父类中的函数属性都是不同的函数，代码无法复用。 组合继承 组合继承又称为伪经典继承，他的核心思想就是原型继承和借用构造函数的继承合二为一。请看下面的例子： 1234567891011121314151617181920212223242526272829function Person(name)&#123; this.name = name; this.hobbies = ["coding","running"];&#125;Person.prototype.sayName = function ()&#123; console.log("我是：" + this.name);&#125;function Man(name)&#123; Person.call(this,name); // 借用构造函数的继承 //这里可以写其他的子类独有的属性&#125;Man.prototype = new Person();// 原型继承部分Man.prototype.constructor = Man;// 修复构造器的指向var lufei = new Man("路飞");var nami = new Man("娜美");lufei.hobbies.push("eat meat");console.log(lufei.hobbies); // ["coding", "running", "eat meat"]console.log(nami.hobbies); // ["coding", "running"]//子类拥有父类原型上的方法lufei.sayName(); // 我是：路飞nami.sayName(); // 我是：娜美// 父类的属性方法可以复用console.log(lufei.sayName === nami.sayName);// true 右上可知，子类的两个对象lufei和nami都拥有了父类的属性，所以继承成功。组合继承是最常用的继承方式之一，但是我们可以看到子类可以调用父类的构造方法，同时父类的引用属性也不再共享。 缺点：调用了两次父类构造函数，比较消耗内存。 一次在第10行，一次再第14行。 原型式继承 要解决组合继承的缺点，我们不得不先说一下原型式继承，它是道格拉斯提出的一种继承方式，其核心思想就是借助原型，用已有的对象创建对象。。请看下面的例子： 123456789101112131415function object(o)&#123;// 通过原型创建对象的方法 function F()&#123;&#125; F.prototype = o; return new F();&#125;var person = &#123; name: "人", sayName: function ()&#123; console.log("我是：" + this.name); &#125;&#125;;var lufei = object(person);lufei.name = "路飞";lufei.sayName();// 我是：路飞 右上可知，子类的对象lufei拥有了父类的方法，继承成功。但是我们每次得自己写一个类似于上面的object方法。ES5考虑到这个问题，把这个方法规范化了，就是大名鼎鼎的Object.create()方法，其本质就是上面的object函数。这个函数接受2个参数，一个是要复制的对象，一个是Object.defineProperties()函数第二个参数相同的结构。所以上面第13行和第14行可以改写为： 12345var lufei = Object.create(person,&#123; name : &#123;//这个对象是属性描述符里面那样的对象 value:"路飞" &#125;&#125;); 这种方式比较方便，它跳过了创建子类这一步，直接创建了子类对象。 缺点1：子类自己独特的属性或方法，是无法复用的。缺点2：没有子类的概念，直接创建了子类对象。 寄生式继承 寄生式继承解决了子类对象拥有自己的属性和方法的问题，其核心思想就是在原型式继承的外面再包装一层，使得返回的对象可以添加自己的属性和方法。。下面这个例子我们直接使用ES5的Object.create了，你可以理解成原型式继承里面的object函数： 12345678910111213141516171819202122232425var person = &#123; name: "人", sayName: function ()&#123; console.log("我是：" + this.name); &#125;&#125;;function createObject(obj)&#123;// 创建子类对象一个方法 var newObj = Object.create(obj);// 原型式继承 newObj.sayHello = function ()&#123; // 这里给每个子对象添加方法 console.log("大家好！！！") &#125; // ... 这里可以添加其他的属性或方法 return newObj;&#125;var lufei = createObject(person);lufei.name = "路飞";lufei.sayName();// 我是：路飞lufei.sayHello();// 大家好！！！var nami = createObject(person);nami.name = "娜美";nami.sayName();// 我是：娜美nami.sayHello();// 大家好！！！ 由上可知，子类的对象lufei和nami即拥有了父类的方法也拥有了子类自己独特的方法sayHello，继承成功。但是它也是直接创建了子对象的。 缺点：没有子类的概念，直接创建了子类对象。 寄生组合式继承 寄生组合式过借用构造函数来继承属性，通过原型链的混成形式来继承方法。其核心思想就是使用寄生式继承来继承父类的原型，然后再将结果指定给子类的原型；子类的构造函数借助构造函数来继承父类。。请看下面的例子： 12345678910111213141516171819202122function inheritPrototype(subType, superType)&#123; var prototype = Object.create(superType.prototype); // 寄生式继承来继承父类的原型 prototype.constructor = subType; // 修复子类构造函数的指向 subType.prototype = prototype; // 修复子类原型的指向&#125;function Person()&#123; this.hobbies = ["coding","running"];&#125;function Man()&#123; Person.call(this); // 借助构造函数继承属性&#125;inheritPrototype(Man, Person);var lufei = new Man();var nami = new Man();lufei.hobbies.push("eat meat");console.log(lufei.hobbies); // ["coding", "running", "eat meat"]console.log(nami.hobbies); // ["coding", "running"] 寄生组合式继承被誉为引用类型最理想的继承方式，也是最重要的一种继承方式。 缺点：除了代码比较多外，没有其他的缺点了！]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>原型</tag>
        <tag>继承</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES5面向对象基础]]></title>
    <url>%2F2019%2F03%2F03%2FES5%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[面向对象的知识时JS中的一个比较重要的概念，我们今天学习一下ES5面向对象的基础内容。 一、 创建对象 工厂模式12345678910function createPerson(name)&#123; var o = new Object(); o.name = name; o.sayName = function()&#123; console.log(this.name); &#125;; return o;&#125;var person1 = createPerson("Orange"); 缺点：无法辨别是一个对象。 JSON对象123456var person1 = &#123; name:"Orange", sayName:function ()&#123; console.log(this.name); &#125;&#125;; 优点：简单。缺点：每次只能创建一个对象，代码无法复用。 构造函数12345678910function Person(name)&#123; this.name = name; this.sayName = function()&#123; console.log(this.name); &#125;; &#125;var person1 = new Person("Orange");person1.sayName(); //"Orange" 优点：可以创建多个对象，可以辨别是对象。下面我们主要讨论的也正是使用构造方法创建的对象。 二、 不使用new关键字会发生什么不使用new的时候相当于时全局变量window调用该方法，this会绑定在全局变量上。由于没有返回值，结果是undefined。12345function Person(name)&#123; this.name = name;// 不使用new时 非严格模式下绑定在全局变量window上了&#125;var person1 = Person("Orange");// 方法的调用console.log(person1);// undefined 三、 new一个对象的时候有返回值怎么办如果返回的是一个对象，那么new出来的结果就是这个对象；如果返回的是非对象的，那么new返回的与没有return语句一样，是一个该类的实例对象。如果没有new的时候，就比如上面这种情况，那就是方法返回什么结果就是什么了。123456789101112function Person1()&#123; this.name = "Person1"; return &#123;haha:"我是一个新的对象"&#125;;// 返回一个对象&#125;function Person2()&#123; this.name = "Person2"; return 123;// 返回一个非对象&#125;var person1 = new Person1();var person2 = new Person2();console.log(person1);// &#123;haha: "我是一个新的对象"&#125;console.log(person2);// Person2 &#123;name: "Person2"&#125; 四、 成员方法 给单个对象添加成员方法 12345678function Person()&#123;&#125;var person1 = new Person();person1.name = "Orange";var person2 = new Person();console.log(person1.name);// "Orange"console.log(person2.name);// undefined 给多个对象添加成员方法 123456789101112function Person(name)&#123; this.name = name;//所有的对象公用的属性 this.age = 20;//所有的对象公用的属性&#125;var person1 = new Person("Orange");var person2 = new Person("小明");person1.age = 21;console.log(person1.name);// "Orange"console.log(person2.name);// "小明"console.log(person1.age);// 21console.log(person2.age);// 20 五、 私有变量构造函数中var声明的变量是私有变量。123456function Person()&#123; var age = 21;//这里相当于私有变量&#125;var person1 = new Person();console.log(person1.age);// undefined 六、 静态方法添加到构造函数上的方法是静态方法，添加到构造函数上的变量是静态变量。12345678910111213141516function Person(name)&#123; this.name = name;&#125;Person.age = 20;//静态变量Person.name = "骗你的"; // 这条语句会忽略 因为name是一个特殊的属性 不能修改Person.sayName = function ()&#123;//静态方法 console.log("sayName:" + this.name);&#125;;var person = new Person("Orange");console.log(person.name);// "Orange"console.log(Person.name);// "Person" 这里是类的名称 哈哈// console.log(person.name);// 这个会报错 静态属性属于类 而不是属于对象 // person.sayName(); // 这个会报错 静态方法属于类 而不是属于对象console.log(Person.age); // 20Person.sayName();// sayName:Person 七、 原型上面说过给多个对象添加成员方法，只要在构造函数中添加this.方法名 = 方法即可，但是这样会出现一个问题就是不同对象的方法是不同的，这样就会增大内存的开销。解决这个问题的办法就是把方法放在函数的外面，然后在函数内部去引用同一个函数。这样解决了这个问题，但是却失去了封装性。解决这个问题的最终办法就是——原型。 每一构造函数写完以后，引擎会加原型的委托，就比如上面的Person类（函数）定义完了以后，引擎会加：1Person.prototype = new Object(); 从上面代码可以看出Person加了一个名叫prototype的静态变量，这个变量就是Person的原型。由于对象是无法访问静态变量的，所以浏览器给每一个对象又加了一个__proto__的属性也指向了这个原型。相当于引擎又执行了下面的代码：1person.__proto__ = Person.prototype; 我们这里总结一下：对象.__proto__属性 和 构造函数.prototype属性 都指向了该类的原型。下面我们把这剪不断理还乱的原型画一张图吧： 由上图可知，原型对象有一个constructor的属性指向了构造方法。也就是：12Person.prototype.constructor === Person;// trueperson.__proto__.constructor === Person;// true 由上面Person.prototype = new Object();可知Person.prototype其实是Object的对象，既然是对象那么就有__proto__属性指向该对象的原型。也就是说：1Person.prototype.__proto__ === Object.prototype;// true 其实Object.prototype也是一个对象那么他的原型是什么呢？我们可以打印一下发现他的原型是null，上图也可以看出。1console.log(Object.prototype.__proto__);// null 说了这么一大堆终于知道了原型是什么了，那么还有一个更重要的东西就是原型链。如果一个对象调用自己没有定义的属性，那么他就会从他们原型中查找，看有没有定义该属性，如果原型中没有就会去原型的原型去寻找，一直找到顶层的Object类的对象（最顶层的null不用找了，肯定没有），这条由原型连起来的链条叫做原型链。 那我们看一个东西，上面person.constructor是什么呢？其实就是Person函数。因为person对象没有constructor属性，所以去person的原型中找也就是person.__proto__而它里面找到了，指向的就是Person函数。 我们也可以用原型来定义对象的属性和方法。1234567891011121314function Person()&#123;&#125;Person.prototype.name = "Orange";Person.prototype.sayName = function()&#123; console.log(this.name);&#125;;var person1 = new Person();var person2 = new Person();person2.name = "小明";person1.sayName();// "Orange"person2.sayName();// "小明" 我们来看一下这个步骤，person1调用sayName的时候由于person1自己没有sayName这个方法，那么就是去它的原型去找也就是Person.prototype，发现有这个方法，那么就调用，而方法中this.name，由于自己并没有name这样一个属性，也会在原型中找，最后找到了是”Orange”。person2找sayName跟之前的是一样的，但是person2有name这个属性，所以就不需要去原型链中找了，该属性的值是”小明”。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>ES5对象</tag>
        <tag>面向对象</tag>
        <tag>原型</tag>
        <tag>OOP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS中属性描述符]]></title>
    <url>%2F2019%2F03%2F03%2FJS%E4%B8%AD%E5%B1%9E%E6%80%A7%E6%8F%8F%E8%BF%B0%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[属性描述符是ES5中的一个重要的概念。它可以对对象做一些特定的高级操作，今天我们就学习一下ES5中的属性描述符。ES5中的属性描述符是由Object类的一个静态方法defineProperty来设置的，该方法接收三个参数，分别是：属性操作的对象、属性名和一个属性描述符的对象。我们来看一个简单的例子：1234567var obj = &#123; a:"a"&#125;;Object.defineProperty(obj,"a",&#123; value:"123"&#125;);console.log(obj.a);//123 这个例子中，我们使用属性描述符将对象obj的a属性的值设置为”123”。属性描述符是由第三个参数来决定属性可以做哪些操作，这个对象可以设置以下的值： 描述符的值 描述 默认值 value 值 undefined writable 是否可写 true configurable 是否可配置 true enumerable 是否可枚举 true set 设置属性的函数 undefined get 获取属性的函数 undefined 接下来我们一一简绍上面的这些值，由于value很简单，上面已经做过解释，就不再重复了。 writable writable表示是否可写，如果其值设置为false，那么修改时会静默失败，严格模式下，会报错TypeError。 12345678var obj = &#123; a:"a"&#125;;Object.defineProperty(obj,"a",&#123; writable:false&#125;);obj.a = "123";//由于writable是false，这里会静默失败console.log(obj.a);//a configurable configurable表示是否可配置，如果其值设置为false，那么将属性描述符重新设置的时候会报错TypeError（无论是否是在严格模式下）；同时delete该属性的时候会静默失败，严格模式会报错TypeError。 1234567891011var obj = &#123; a:"a"&#125;;Object.defineProperty(obj,"a",&#123; configurable:false,&#125;);Object.defineProperty(obj,"a",&#123; configurable:true,// 将configurable为false的重新开启会直接报错 value:"111",&#125;);console.log(obj.a); 下面给出一个delete的例子： 12345678var obj = &#123; a:"a"&#125;;Object.defineProperty(obj,"a",&#123; configurable:false,&#125;);delete obj.a;// 这个地方会静默失败 严格模式下会报错console.log(obj.a);//"a" configurable有三点需要注意的： 2.1 所谓的不可配置是不能修改，如果重新设置相同的属性描述符是不会报错的： 12345678910var obj = &#123; a:"a"&#125;;Object.defineProperty(obj,"a",&#123; configurable:false&#125;);Object.defineProperty(obj,"a",&#123; configurable:false// 这个地方并不会报错 因为属性描述符并没有改变&#125;);console.log(obj.a);//"a" 2.2 如果configurable为false的时候仍然可以把writable从true改成false，但是不能把writable从false修改成true。 123456789101112var obj = &#123; a:"a"&#125;;Object.defineProperty(obj,"a",&#123; configurable:false, writable:true&#125;);Object.defineProperty(obj,"a",&#123; writable:false // writable从true设置为false是可以的&#125;);obj.a = "b";// writable为false 静默失败console.log(obj.a);//"a" 2.3 如果configurable为false并且writable从true的时候，那么修改value是可以的。 123456789101112var obj = &#123; a:"a"&#125;;Object.defineProperty(obj,"a",&#123; configurable:false, writable:true, value:"111"&#125;);Object.defineProperty(obj,"a",&#123; value:"222" // value其实是由writable来决定的&#125;);console.log(obj.a);//"222" enumerable enumerable表示是否可枚举，如果设置为false，那么for-in中获取不到该值。 1234567891011var obj = &#123; a:"a", b:"b", c:"c"&#125;;Object.defineProperty(obj,"b",&#123; enumerable:false&#125;);for (var key in obj) &#123; console.log(obj[key]);// 依次打印"a" "c"&#125; 通常判断一个属性是否属于一个对象我们可以使用in操作符和hasOwnProperty方法，对于不可枚举的属性，他们返回的都是true，如上面的不可枚举的属性b： 12console.log("b" in obj);// trueconsole.log(obj.hasOwnProperty("b"));// true 那么如何区分某个属性是不可枚举的呢？可以利用对象的propertyIsEnumerable方法。 1console.log(obj.propertyIsEnumerable("b"));// false 如果要获取对象的所有属性（键），那怎么办？可以使用下面两个方法： 12console.log(Object.keys(obj));// 获取所有可枚举的属性 结果是 ["a", "c"]console.log(Object.getOwnPropertyNames(obj));// 获取所有的属性，不管是否可以枚举 结果是 ["a", "b", "c"] set和get set和get通常是方法，分别定义了设置值和获取值是的逻辑，我们这里给出一个例子，当设置了一个数值读取的时候返回这个数值的平方： 123456789101112var obj = &#123;&#125;;Object.defineProperty(obj,"a",&#123; set : function (_a)&#123; this._a = _a;//这个地方必须注意 这里使用的是_a而不是a 因为如果是a的话会陷入死循环 &#125;, get : function ()&#123; return this._a * this._a; &#125;&#125;);obj.a = 4;//这里会调用set方法console.log(obj.a);// 这里会调用get方法 打印16 set和get也可以定义在对象上，而不使用属性描述符，如下： 12345678910var obj = &#123; set a(_a)&#123;//这个地方和函数属性的写法有一点点的区别 this._a = _a; &#125;, get a()&#123; return this._a * this._a; &#125;&#125;;obj.a = 4;//这里会调用set方法console.log(obj.a);// 这里会调用get方法 打印16 那么问题来了，如果同一次设置属性描述符中既有get和set又有value那么会以哪个为准呢？这种情况下浏览器就会报错，也就是不允许这么做。 如果多次设置同一个属性的属性描述符那么后面的会覆盖前面的。 1234567891011121314151617181920var obj = &#123; a:123&#125;;Object.defineProperty(obj,"a",&#123; set :function (_a)&#123; this._a = _a; &#125;, get :function ()&#123; return this._a * this._a; &#125;,&#125;);obj.a = 4;console.log(obj.a);// 16Object.defineProperty(obj,"a",&#123; writable:true, value:321&#125;);console.log(obj.a);// 321 补充 在调用Object.defineProperty方法创建一个新的属性的时候，如果不指定writable，configurable，enumerable的时候默认值是false，如果只是修改已定义的属性的时候那么就是默认值true。 12345678910var obj = &#123; a:"111"&#125;;Object.defineProperty(obj,"a",&#123; value:"a"&#125;);Object.defineProperty(obj,"b",&#123; value:"b"&#125;);console.log(Object.keys(obj));//b是新的 所以是不可枚举的 所以打印["a"] 获取属性描述符，可以使用Object.getOwnPropertyDescriptor方法。 Object.getOwnPropertyDescriptor(obj,"a"); 批量设置多个属性描述符的时候，可以使用Object.defineProperties方法。 Object.defineProperties(obj,{ a:{value:"aaa",writable:false}, b:{value:"bbb",writable:false}, });]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>属性描述符</tag>
        <tag>defineProperty</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[this到底是什么？]]></title>
    <url>%2F2019%2F02%2F27%2Fthis%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[this是JavaScript中的一个重要的概念，它的值并不是由声明的位置来决定的，而是由调用的位置来决定。正是因为这个原因在不同的语境下它的值是不一样的，所以它成了面试官最喜欢考察的内容。 通常this由下面这四条法则就可以确定： new绑定，指向创建的对象。 12345function Student(name)&#123; this.name = name;&#125;var s = new Student("小明");console.log(s.name);//小明 通过new关键字创建的对象，那么构造方法中的this指向该对象。 call、apply、bind等显式绑定。 1234567891011function sayName()&#123; console.log(this.name);&#125;var obj1 = &#123; name : "小李"&#125;;var obj2 = &#123; name : "小秋"&#125;;sayName.call(obj1);//小李sayName.call(obj2);//小秋 拥有上下文对象的隐式绑定。 1234567var obj = &#123; name : "小秋", sayName : function ()&#123; console.log(this.name); &#125;&#125;;obj.sayName();//小秋 默认绑定：严格模式下绑定undefined，非严格模式下绑定全局变量（浏览器环境下是window）。 12345function sayName()&#123; console.log(this.name);&#125;var name = "小李";sayName();//小李 this的绑定也是有优先级的，它的优先级也是按照上面4条从1到4的。没错，你没有看错new绑定比显式绑定的优先级还要高，虽然这种情况并不多见，这里给出一个简单的例子，供大家参考：123456789function Student(name)&#123; this.name = name;&#125;var obj = &#123; name:"小李"&#125;;var StudentWithBind = Student.bind(obj);//bind绑定var swb = new StudentWithBind("小秋");//new绑定console.log(swb.name);//小秋 上面这4条规则适用于大量的情况，但是俗话说的好“凡是都有例外”，下面2条特殊情况要格外注意。 显示绑定（call、apply、bind）如果绑定的是null或者undefined，在严格模式下会绑定对应的值，在非严格模式下绑定全局变量（浏览器环境下是window）。 12345678910function sayName()&#123; console.log(this.name);&#125;var obj = &#123; name : "小李", sayName :sayName&#125;var name = "小秋";obj.sayName.call(null);//小秋sayName.call();//小秋 由于绑定null或者undefined在非严格模式下会绑定全局变量window这样会很危险。如果这里非要绑定一个对象但是又不绑定全局变量可以绑定一个空对象就比如{}或者Object.create(null)，两者的区别是后者不会创建Object.prototype这个委托，也就是后者比前者更空。 间接引用，本质上是默认绑定。 123456789101112function sayName()&#123; console.log(this.name);&#125;;var obj1 = &#123; name : "小李", sayName : sayName&#125;var obj2 = &#123; name : "小秋"&#125;var name = "小芹";(obj2.sayName = obj1.sayName)();//"小芹" JS中每一个表达式都有一个返回值，上面obj2.sayName = obj1.sayName也是表达式，返回值是函数sayName的引用。而把引用括起来是为了保证这是一个整体，后面的括号是函数的调用。也就是说这里相当于是(sayName)()，进一步相当于sayName()，很显然相当于是window来调用的。 箭头函数，根据所处的环境（作用域）来决定。 12345678910111213var sayName = (function ()&#123; var name = "小明" //立即执行函数 这个地方的this是window return ()=&gt;&#123; console.log(this.name); &#125;;//箭头函数中的this由所处的作用域来决定 也就是window&#125;)();var name = "小华";var obj = &#123; name:"小芳"&#125;;sayName();//小华sayName.call(obj);//sayName对应的箭头函数所处的作用域已指向window 即使call也不能改变指向 故打印小华 其他情况： HTML事件中的this指向该DOM元素。 123456&lt;button onclick="handleClick(this)"&gt;点我&lt;/button&gt;&lt;script&gt; function handleClick(obj)&#123; obj.innerHTML = "点击了";//按钮的文案会修改为 点击了 &#125;&lt;/script&gt; JQuery获取到的DOM元素，this指向该DOM元素，$(this)是该DOM对象的JQuery封装对象。 1234$("#id").click(function() &#123; console.log(this);//选中的DOM元素 console.log($(this));//选中DOM元素的JQuery封装对象&#125;);]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>this</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用console.log在控制台打印图片]]></title>
    <url>%2F2019%2F02%2F21%2F%E4%BD%BF%E7%94%A8console-log%E5%9C%A8%E6%8E%A7%E5%88%B6%E5%8F%B0%E6%89%93%E5%8D%B0%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[在项目的开发中我们经常使用console.log方法在控制台输出数据，看数据是否正确。console是全局变量window（或global）下的一个对象，它给我们提供了很多的方法，我们可以打印一下这个对象，如下： 我们可以看到除了log方法以外还有info、warn、error等方法，类似于常用的日志系统中的不同级别。1234console.log("log");console.info("info");console.warn("warn");console.error("error"); 显示出来的效果在Chrome里面的效果如下: 其中log和info的区别有点不太明显，我们在Firefox下再次打印可以看到info级别的左边有个图标: 除了这几个不同级别的打印外，还有一个使用的比较多方法就是console.table，它可以用表格列出一个对象的属性： 最后再简绍一个可以清空控制台的一个方法就是console.clear()，其他的方法大家可以自己试试，还是挺有意思的。 说了这么多我们回归到最常用的console.log()吧，他可以打印一些数据，但是很多人不知道其实它还可以添加占位符，类似于C语言的printf函数，具体可以使用的占位符如下： 占位符 作用 %s 字符串 %d 或者 %i 整数 %f 浮点数 %o 可展开的DOM %O 列出DOM的属性 %c 根据提供的css样式格式化字符串 我们试一下前三个：123console.log("打印的字符串是：%s","JavaScript很简单");console.log("打印的整数是：%d",123.456);console.log("打印的浮点数是：%f",123.456); 结果如下： console.log(&quot;%o&quot;,document.body);的结果大致如下： console.log(&quot;%O&quot;,document.body);的结果大致如下： 所有占位符中最牛逼的当然是%c了，因为他可以添加样式，这样就可以美化我们的打印效果了。先来看个例子：1console.log("%c神奇的console","font-size: 24px;font-style: italic;color: brown;"); 结果如下： 最后我们回归主题，打印一张图片，思路就是使用background-image来添加一张背景图片。这里需要要注意的是，设置背景以后要有内容，不然还是不会显示（当然也可以添加样式让内容撑开，大家可以试试）。我们这里随便写个内容就比如一个“+”，当然我们还要设置背景图片显示大小，并且让内容透明（不显示内容）。为了方便代码的阅读，样式部分我使用了ES6的模板字符串，具体代码如下：1234567console.log("%c+", `font-size: 1px; padding: 122px 217px; background-image: url(http://imgsrc.baidu.com/forum/w=580/sign=780874ff6e380cd7e61ea2e59145ad14/fb20952bd40735fa2ebbc5f695510fb30e2408ea.jpg); background-size: contain; background-repeat: no-repeat; color: transparent;`); 结果如下：]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>console.log</tag>
        <tag>JS API</tag>
        <tag>控制台图片</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《程序是怎么跑起来的》读书笔记]]></title>
    <url>%2F2019%2F02%2F21%2F%E3%80%8A%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[最近看了矢泽久雄[日]的另一本书《程序是怎么跑起来的》，同样把大学学到的知识又复习了一遍，主要包括计算机组成原理、操作系统、数字逻辑、数据结构、编程语言等知识。下面是我记录的一些书中的重点： CPU 是英文 Central Processing Unit（中央处理器）的缩写，相当于计算机的大脑，它的内部由数百万至数亿个晶体管构成。 CPU 和内存是由许多晶体管组成的电子部件，通常称为 IC（Integrated Circuit，集成电路）。从功能方面来看，如图 1-2 所示，CPU 的内部由寄存器、控制器、运算器和时钟四个部分构成，各部分之间由电流信号相互连通。寄存器 可用来暂存指令、数据等处理对象，可以将其看作是内存的一种。 一个 CPU 内部会有 20～100 个寄存器。控制器 负责把内存上的指令、数据等读入寄存器，并根据指令的执行结果来控制整个计算机。运算器 负责运算从内存读入寄存器的数据。时钟 负责发出 CPU 开始计时的时钟信号。不过，也有些计算机的时钟位于 CPU 的外部。 通常所说的内存指的是计算机的主存储器（main memory），简称主存。主存通过控制芯片等与 CPU 相连，主要负责存储指令和数据。主存由可读写的元素构成，每个字节（1 字节 = 8 位 ）都带有一个地址编号。CPU 可以通过该地址读取主存中的指令和数据，当然也可以写入数据。但有一点需要注意，主存中存储的指令和数据会随着计算机的关机而自动清除。 通常我们将汇编语言编写的程序转化成机器语言的过程称为汇编 ；反之，机器语言程序转化成汇编语言程序的过程则称为反汇编 。 机器语言是指 CPU 能直接解释和执行的语言。 编译是指将使用高级编程语言编写的程序转换为机器语言的过程，其中，用于转换的程序被称为编译器（compiler）。 寄存器 功能 累加寄存器（accumulator register） 存储执行运算的数据和运算后的数据 标志寄存器（flag register） 存储运算处理后的CPU的状态 程序计数器（program counter） 存储下一条指令所在内存的地址 基址寄存器（base register） 存储数据内存的起始地址 变址寄存器（index register） 存储基址寄存器的相对地址 通用寄存器（general purpose register） 存储任意数据 指令寄存器（instruction register） 存储指令。CPU内部使用，程序员无法通过程序对该寄存器进行读写操作 栈寄存器（stack register） 存储栈区域的起始地址 储执行运算的数据和运算后的数据 CPU 是具有各种功能的寄存器的集合体。其中，程序计数器、累加寄存器、标志寄存器、指令寄存器和栈寄存器都只有一个，其他的寄存器一般有多个。程序计数器和标志寄存器比较特殊。另外，存储指令的指令寄存器等寄存器，由于不需要程序员做多关注。 操作系统（operating system）是指管理和控制计算机硬件与软件资源的计算机程序。 程序的流程分为顺序执行、条件分支和循环三种。顺序执行 是指按照地址内容的顺序执行指令。条件分支 是指根据条件执行任意地址的指令。循环 是指重复执行同一地址的指令。 变址寄存器的值就相当于高级编程语言程序中数组的索引功能。 CPU 则会把基址寄存器＋变址寄存器的值解释为实际查看的内存地址。变址寄存器的值就相当于高级编程语言程序中数组的索引功能。 8 位 = 1 字节 计算机处理信息的最小单位——位 ，就相当于二进制中的一位。位的英文 bit 是二进制数位（binary digit）的缩写。 字节是最基本的信息计量单位。位是最小单位，字节是基本单位。内存和磁盘都使用字节单位来存储和读写数据，使用位单位则无法读写数据。因此，字节是信息的基本单位。 用字节单位处理数据时，如果数字小于存储数据的字节数（= 二进制数的位数），那么高位上就用 0 填补。例如，100111 这个 6 位二进制数，用 8 位（= 1 字节）表示时为 00100111，用 16 位（= 2 字节）表示时为 0000000000100111。 移位运算 指的是将二进制数值的各数位进行左右移位（shift = 移位）的运算。移位有左移（向高位方向）和右移（向低位方向）两种。 二进制数左移后就会变成原来的 2 倍、4 倍、8 倍……反之，二进制数右移后则会变成原来的 1/2、1/4、1/8…… 进制数中表示负数值时，一般会把最高位作为符号来使用，因此我们把这个最高位称为符号位。符号位是 0 时表示正数 ，符号位 是 1 时表示负数。 补码，我们需要将二进制数的各数位的数值全部取反6 ，然后再将结果加 1。 负数用补码表示 移位后需要在最高位补 0。类似于霓虹灯往右滚动的效果。这就称为逻辑右移。 将二进制数作为带符号的数值进行运算时，移位后要在最高位填充移位前符号位的值（0 或 1）。这就称为算术右移。 符号扩充 就是指在保持值不变的前提下将其转换成 16 位和 32 位的二进制数。将 01111111 这个正的 8 位二进制数转换成 16 位二进制数时，很容易就能得出 0000000001111111 这个正确结果，但是像 11111111 这样用补数来表示的数值，该如何处理比较好呢？实际上处理方法非常简单，将其表示成 1111111111111111 就可以了。也就是说，不管是正数还是用补数表示的负数，都只需用符号位的值（0 或者 1）填充高位即可。这就是符号扩充的方法。 算术运算 是指加减乘除四则运算。逻辑运算 是指对二进制数各数字位的 0 和 1 分别进行处理的运算，包括逻辑非（NOT 运算）、逻辑与（AND 运算）、逻辑或（OR 运算）和逻辑异或（XOR 运算9 ）四种。 逻辑非 指的是 0 变成 1、1 变成 0 的取反操作。逻辑与 指的是“两个都是 1”时，运算结果为 1，其他情况下运算结果都为 0 的运算。逻辑或 指的是“至少有一方是 1”时，运算结果为 1，其他情况下运算结果都是 0 的运算。逻辑异或 指的是排斥相同数值的运算。“两个数值不同”，也就是说，当“其中一方是 1，另一方是 0”时运算结果是 1，其他情况下结果都是 0。 有一些十进制数的小数无法转换成二进制数”。例如，十进制数 0.1，就无法用二进制数正确表示，小数点后面即使有几百位也无法表示。 很多编程语言中都提供了两种表示小数的数据类型，分别是双精度浮点数和单精度浮点数。双精度浮点数类型 用 64 位、单精度浮点数类型 用 32 位来表示全体小数。在 C 语言中，双精度浮点数类型和单精度浮点数类型分别用 double 和 float 来表示。 浮点数 是指用符号、尾数、基数和指数这四部分来表示的小数。 符号部分 是指使用一个数据位来表示数值的符号。该数据位是 1 时表示负，为 0 时则表示“正或者 0” 在二进制数中，我们使用的是“将小数点前面的值固定为 1 的正则表达式 ”。 指针 也是一种变量，它所表示的不是数据的值，而是存储着数据的内存的地址。通过使用指针，就可以对任意指定地址的数据进行读写。 数组 是指多个同样数据类型的数据在内存中连续排列的形式。作为数组元素的各个数据会通过连续的编号被区分开来，这个编号称为索引 （index）。 栈用的是 LIFO（Last Input First Out，后入先出）方式，而队列用的则是 FIFO（First Input First Out，先入先出）方式。 在数组的各个元素中，除了数据的值之外，通过为其附带上下一个元素的索引，即可实现链表 。 二叉查找树是指在链表的基础上往数组中追加元素时，考虑到数据的大小关系，将其分成左右两个方向的表现形式。 内存和磁盘也都被归类为存储部件。不过，利用电流来实现存储的内存，同利用磁效应来实现存储的磁盘，还是有差异的。而从存储容量来看，内存是高速高价，而磁盘则是低速廉价。 一般把输入装置、输出装置、存储器、运算器和控制器这 5 种部件设备称 为计算机的 5 大部件。 内存主要是指主内存（负责存储 CPU 中运行的程序指令和数据的内存），磁盘主要是指硬盘。 存储在磁盘中的程序需要读入到内存后才能运行。 磁盘缓存 指的是把从磁盘中读出的数据存储到内存空间中的方式。这样一来，当接下来需要读取同一数据时，就不用通过实际的磁盘，而是从磁盘缓存中把内容读出。使用磁盘缓存可以大大改善磁盘数据的访问速度 虚拟内存 是指把磁盘的一部分作为假想的内存来使用。这与磁盘缓存是假想的磁盘（实际上是内存）相对，虚拟内存是假想的内存（实际上是磁盘）。 为了实现虚拟内存，就必须把实际内存 （也可称为物理内存 ）的内容，和磁盘上的虚拟内存的内容进行部分置换（swap），并同时运行程序。 虚拟内存的方法有分页式 和分段式 两种。Windows 采用的是分页式。该方式是指，在不考虑程序构造的情况下，把运行的程序按照一定大小的页（page）进行分割，并以页为单位在内存和磁盘间进行置换。在分页式中，我们把磁盘的内容读出到内存称为 Page In，把内存的内容写入磁盘称为 Page Out。一般情况下，Windows 计算机的页的大小是 4KB。 为了实现虚拟内存功能，Windows 在磁盘上提供了虚拟内存用的文件（page file，页文件 ）。该文件由 Windows 自动做成和管理。文件的大小也就是虚拟内存的大小，通常是实际内存的相同程度至两倍程度。 虚拟内存无法彻底解决内存不足的问题。 DLL （Dynamic Link Library）文件 ，顾名思义，是在程序运行时可以动态加载 Library（函数和数据的集合）的文件。此外，还有一个需要大家注意的地方，那就是多个应用可以共有同一个 DLL 文件。而通过共有同一个 DLL 文件则可以达到节约内存的效果。 栈清理处理 是指，把不需要的数据从接收和传递函数的参数时使用的内存上的栈区域中清理出去。 磁盘是通过把其物理表面划分成多个空间来使用的。划分的方式有扇区方式 和可变长方式 两种，前者是指将磁盘划分为固定长度的空间，后者则是指把磁盘划分为长度可变的空间。一般的 Windows 计算机所使用的硬盘和软盘，采用的都是扇区方式。扇区方式中，把磁盘表面分成若干个同心圆的空间就是磁道 ，把磁道按照固定大小（能存储的数据长度相同）划分而成的空间就是扇区。 扇区是对磁盘进行物理读写的最小单位。Windows 中使用的磁盘，一般 1 个扇区是 512 字节。 Windows 在逻辑方面（软件方面）对磁盘进行读写的单位是扇区整数倍簇 。根据磁盘容量的不同，1 簇可以是 512 字节（1 簇 = 1 扇区）、1KB（1 簇 = 2 扇区）。 不管是硬盘还是软盘，不同的文件是不能存储在同一个簇中的，否则就会导致只有一方的文件不能被删除。因此，不管是多么小的文件，都会占用 1 簇的空间。这样一来，所有的文件都会占用 1 簇的整数倍的磁盘空间。 文件是将数据存储在磁盘等存储媒介中的一种形式。程序文件中存储数据的单位是字节。 把文件内容用“数据 × 重复次数”的形式来表示的压缩方法称为 RLE（Run Length Encoding，行程长度编码）算法。 虽然针对相同数据经常连续出现的图像、文件等，RLE 算法可以发挥不错的效果，但它并不适合文本文件的压缩。 我们把能还原到压缩前状态的压缩称为可逆压缩 ，无法还原到压缩前状态的压缩称为非可逆压缩。 运行环境 = 操作系统 ＋ 硬件 CPU 只能解释其自身固有的机器语言。不同的 CPU 能解释的机器语言的种类也是不同的。 机器语言的程序称为本地代码 （native code）。程序员用 C 语言等编写的程序，在编写阶段仅仅是文本文件。文本文件（排除文字编码的问题）在任何环境下都能显示和编辑。我们称之为源代码 。通过对源代码进行编译，就可以得到本地代码。 同样机型的计算机，可安装的操作系统类型也会有多种选择。 BIOS 存储在 ROM 中，是预先内置在计算机主机内部的程序。BIOS 除了键盘、磁盘、显卡等基本控制程序外，还有启动“引导程序”的功能。引导程序 是存储在启动驱动器起始区域的小程序。操作系统的启动驱动器一般是硬盘，不过有时也可以是 CD-ROM 或软盘。 开机后，BIOS 会确认硬件是否正常运行，没有问题的话就会启动引导程序。引导程序的功能是把在硬盘等记录的 OS 加载到内存中运行。虽然启动应用是 OS 的功能，但 OS 并不能自己启动自己，而是通过引导程序来启动。 Dump 是指把文件的内容，每个字节用 2 位十六进制数来表示的方式。 能够把 C 语言等高级编程语言编写的源代码转换成本地代码的程 序称为编译器 。每个编写源代码的编程语言都需要其专用的编译器。将 C 语言编写的源代码转换成本地代码的编译器称为 C 编译器。 编译器首先读入代码的内容，然后再把源代码转换成本地代码。 读入的源代码还要经过语法解析、句法解析、语义解析等，才能生成本地代码 此外，还有一种交叉编译器 ，它生成的是和运行环境中的 CPU 不同的 CPU 所使用的本地代码。 编译器转换源代码后，就会生成本地文件。不过，本地文件是无法直接运行的。为了得到可以运行的 EXE 文件，编译之后还需要进行“链接”处理。 编译后生成的不是 EXE 文件，而是扩展名为“.obj”的目标文件。 把多个目标文件结合，生成 1 个 EXE 文件的处理就是链接 ，运行连接的程序就称为链接器 （linkage editor 或连结器）。 Windows 以函数的形式为应用提供了各种功能。这些形式的函数称为 API （Application Programming Interface，应用程序接口）。 Windows 中，API 的目标文件，并不是存储在通常的库文件中，而是存储在名为 DLL （Dynamic Link Library）文件 的特殊库文件中。 无论是 C 语言还是 C++，如果没有在程序中明确释放堆的内存空间，那么即使在处理完毕后，该内存空间仍会一直残留。这个现象称为内存泄露 （memory leak），它是令 C 语言及 C++ 的程序员们十分头疼的一个 bug（程序的错误）。如果内存泄露一直存在的话，就有可能会造成内存不足而导致宕机。这就好比，如果水龙头一直嘀嗒嘀嗒地漏水，那么一晚上的时间水桶就可能会装满并溢出。 操作系统（Operating System）也称为基础软件。操作系统是计算机运行时不可或缺的控制程序，以及在控制程序下运转的为其他软件运行提供操作环境的软件的统称。另外，在操作系统上运行的应用也称为“应用程序”。 汇编语言源文件的扩展名，通常用“.asm”来表示。 栈 是存储临时数据的区域，它的特点是通过 push 指令和 pop 指令进行数据的存储和读出。往栈中存储数据称为“入栈”，从栈中读出数据称为“出栈”。 IN 指令 通过指定端口号的端口输入数据，并将其存储在 CPU 内部的寄存器中。OUT 指令 则是把 CPU 寄存器中存储的数据，输出到指定端口号的端口。 I/O 是 Input/Output 的缩写。显示器、键盘等外围设备都有各自专用的 I/O 控制器。I/O 控制器中有用于临时保存输入输出数据的内存。这个内存就是端口 。 各端口之间通过端口号 进行区分。端口号也称为 I/O 地址 。 IRQ 是用来暂停当前正在运行的程序，并跳转到其他程序运行的必要机制。该机制称为中断处理 。中断处理在硬件控制中担当着重要角色。因为如果没有中断处理，就有可能出现处理无法顺畅进行的情况 获取伪随机数的公式。该公式称为线性同余法 。如果把 Ri 作为当前随机数的话，那么下一个出现的随机数 Ri + 1 就可以用下面的公式来获取。R i + 1 = (a × Ri + b ) mod c 这种周期性是伪随机数的特征，也是为什么不是真随机数的原因。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>计算机通用知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《计算机是怎样跑起来的》读书笔记]]></title>
    <url>%2F2019%2F02%2F20%2F%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[最近看了矢泽久雄[日]的《计算机是怎样跑起来的》，把大学学到的知识又复习了一遍，主要包括计算机组成原理、操作系统、编程语言、数据库等知识。下面是我记录的一些书中的重点： 计算机的三大原则： 计算机是执行输入、运算、输出的机器 程序是指令和数据的集合 计算机的处理方式有时与人们的思维习惯不同 计算机是执行输入、运算、输出的机器。 程序是指令和数据的集合。 指令，就是控制计算机进行输入、运算、输出的命令。 使用计算机的目的就是为了提高工作效率。 计算机内部主要由被称为IC的元件组成，虽然在IC家族中有功能各异的各种IC，但在这里希望记住的只有三种：CPU（处理器）、内存以及I/O。CPU是计算机的大脑，在其内部可对数据执行运算并控制内存和I/O。内存用于存储指令和数据。I/O负责把键盘、鼠标、显示等周边设备和主机连接在一起，实现数据的输入和输出。 在机器语言程序中，虽然都是0和1的组合，但每个组合都是有特定含义的指令或数据。可是对人类来说，如果只看0和1的话，恐怕很难判断各个组合都表示什么 于是就有人发明了一种编程方法，根据表示指令功能的英语单词起一个相似的昵称，并将这个昵称赋予给0和1的组合。这种类似英语单词的昵称叫做“助记符”，使用助记符的编程语言叫做“汇编语言”。 既然数据的运算是在CPU中进行的，那么在CPU内部就应该有存储数据的地方。这种存储数据的地方叫做“寄存器”。虽然也叫寄存器，但是与I/O的寄存器不同，CPU的寄存器不仅能存储数据，还具备对数据进行运算的能力。CPU带有什么样的寄存器取决于CPU的种类。 A寄存器也叫做“累加器”，是运算的核心。所以连接到它上面的导线也一定会比其他寄存器多。F寄存器也叫做“标志寄存器”，用于存储运算结果的状态，比如是否发生了进位、数字大小的比较结果等。PC寄存器也叫做“程序指针”，存储着指向CPU接下来要执行的指令的地址。PC寄存器的值会随着滴答滴答的时钟信号自动更新，可以说程序就是依靠不断变化的PC寄存器的值运行起来的。SP寄存器也叫做“栈顶指针”，用于在内存中创建一块称为“栈”的临时数据存储区域 用汇编语言编写的程序是不能直接运行的，必须先转换成机器语言。机器语言是唯一一种CPU能直接理解的编程语言。 程序的流程总共有三种：顺序、条件分支、循环。 结构化程序设计就是“为了把程序编写的具备结构性，仅使用顺序结构、条件分支和循环表示程序的流程即可，而不再使用跳转指令”。 中断处理是指计算机使程序的流程突然跳转到程序中的特定地方，这样的地方被称为中断处理例程（Rountine）或是中断处理程序（Handler），而这种跳转是通过CPU所具备的硬件功能实现的。 用两个数中较大的数减去较小的数（步骤），反复进行上述步骤，直到两个数的值相等（步骤的终止）。如果最终这两个数相同，那么这个数就是最大公约数。也就是著名的“辗转相除法”。 思考算法的时候，要先在纸上用文字或图表描述出解决问题的步骤，而不是立即开始编写代码。 在一般的个人计算机中，内存内部被分割成了若干个数据存储单元，每个单元可存储8比特的数据（8比特=1字节）。为了区分各个单元，每个单元都被分配了一个编号，这个编号被称为“地址”（门牌号码）。如果一台个人计算机装配有64M字节内存，那么就会有从0到64M（1M=100万）这么多个地址。 数组是数据结构的基础，只要使用数组就能通过程序实现各种各样的算法以处理大量的数据 “继承”（Inheritance），“封装”（Encapsulation），“多态”（Polymorphism，也称为多样性和多义性）被称为面向对象编程的三个基本特性。 继承指的是通过继承已存在的类所拥有的成员而生成新的类。封装指的是在类所拥有的成员中，隐藏掉那些没有必要展示给该类调用者的成员。多态指的是针对同一种消息，不同的对象可以进行不同的操作 数据库进行的操作的种类通常称为CRUD。CRUD由以下四种操作的英文名称的首字母组成，即记录的插入（Create）、获取（Refer）、更新（Update）、删除（Delete）。 为了对数据库进行CRUD操作，就必须从应用程序向DBMS发送命令。这里所使用的命令就是SQL语言（Structural Query Language，结构化查询语言）。 CRUD中的C,R,U,D分别对应着SQL语言中的INSERT（插入）、SELECT（查询）、UPDATE（更新）、DELETE（删除）语句。 在每块网卡的ROM（Read Only Memory，只读存储器）中都预先烧录一个唯一的MAC地址。网卡制造厂商负责确定这个MAC地址是什么。因为MAC地址是由制造厂商的编号和产品编号两部分组成，所以世界上的每个MAC地址都是独一无二的。 在因特网的世界中，到处传输的都是附带了IP地址的数据，但能够标识作为数据最终接收者的网卡的，还是MAC地址。于是在计算机中就加入了一种程序，用于实现由IP地址到MAC地址的转换，这种功能被称为ARP（Address Resolution Protocol，地址解析协议）。 在公开密钥加密技术中，用于加密的密钥可以公开给全世界，因此称为“公钥”，而用于解密的密钥是只有自己才知道的秘密，因此称为“私钥”。 若立志成为计算机行业的专家，就不能仅仅关注技术了。虽然又懂技术又懂计算机确实令人感到兴奋，但如果只是这样的话，早晚有一天工作会变得没那么有意思。有些人在30岁左右就选择离开计算机行业，不是因为他们追赶不上技术前进的步伐，而是因为觉得工作变得无聊了。专家也好，普通人也罢，只有成熟感才会觉得工作有意义。 SE（System Engineer系统工程师）也好，程序员也罢，所有和计算机相关的工程师都要有这样一种意识：我们要让计算机技术服务于社会。如果能有这样的决心，就应该能够作为一生的事业和计算机愉快地相处下去。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>计算机通用知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《我的第一本地理启蒙书》读书笔记]]></title>
    <url>%2F2019%2F02%2F17%2F%E3%80%8A%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E6%9C%AC%E5%9C%B0%E7%90%86%E5%90%AF%E8%92%99%E4%B9%A6%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[这是新年第一篇笔记，祝愿大家新年快乐。作为一年只回去一次家的我，给亲戚的礼物是必不可少的，其中这本《我的第一本地理启蒙书》就是我送给亲戚家小朋友的一本小书。回家坐了将近30个小时的火车的我也是独自把这本书看完了。 这本书适合小学和初中的小朋友，内容也是挺有意思的，下面是我觉得一些比较重要的部分： 一、方位有东南西北，还有东北、东南、西北、西南，为什么不叫北东、南东、北西、南西等呢？有种说法是，人们在命名过程中，一般会遵循由易到难，由简单到复杂的原则。日常生活中太阳从东边升起，西边落下，被人用来作为定义的基础，后来又在此基础上衍生出南北两个方向。 二、为什么指南针不叫指北针？有种说法是因为南方朝阳，代表生机和尊贵，所以大家都叫指南针。 三、辨别方位的方法： 使用指南针 木枝叶稠密的一方是南方 苔藓稠密的一方是北方（苔藓喜阴） 年轮稀疏的是南方（朝南长得快） 雪融化快的是南方 蚂蚁窝一般在树的南边（南边温暖） 四、地名常用的命名规则： 河山是大地的符号，中国很多地名都与河山有关系，通常用河与山为界。 比如河北，河南，以黄河为界。 湖北，湖南，以洞庭湖为界。 南岳衡山附近有衡山县 衡东 衡阳等。 淮河沿岸有淮安 淮北 淮南等 古人称：“南水北谓之阳，山北水南谓之阴。”也就是北边是阳，南边是阴。就比如，咸阳就是渭水北边（咸有全部的意思）。邵阳，就是邵水的北边。淮阳、汾阳、沈阳、洛阳、汉阳分别是淮河、汾水、沈水、洛河、汉水的北边。江阴、淮阴、汉阴、湘阴分别是长江、淮河、汉水、湘江的南边。 河流的发源地通常称为源。比如湟源，就是黄河支流湟水的源头。 位于江河中游的地名通常前面加临，如临沂。 接近河口的地方，通常后面加个口。如汉口，指汉江流入长江的地方。 有的地方能政治安定，安居乐业通常会加安、宁、平、定，比如延安。 人文历史典故也是命名的一个规则。 五、为什么水总是从西向东？因为水往低处流，我国地势是西面高，东面低。 六、地球以赤道为南北半球的分界线。 七、地球上竖着的是经线，横着的是纬线。赤道以北是北纬，南边是南纬，各90度。北极点和南极点是90度，赤道是0度。经线以英国格林尼治天文台为0度（即本初子午线）。本初子午线以东是东经，以西为西经，各180度。东经180度和西经180度在太平洋上重叠。东西半球以西经20度和东经160度来划分（不是0度）。 八、地球朝着太阳的一面为白天，背着太阳的一面是黑夜。 九、地球会自转和滚转，自转是绕着地轴转的，是南北极点的连线。但是这个线不是垂直于滚转的平面，从而有了一年四季。 十、近日点远日点各个星体绕太阳公转的轨道大致是一个椭圆，它的长直径和短直径相差不大，可近似为正圆。太阳就在这个椭圆的一个焦点上，而焦点是不在椭圆中心的，因此星体离太阳的距离，就有时会近一点，有时会远一点。离太阳最近的时候，这一点位置叫做近日点。离太阳最远的时候，这一点位置叫做远日点。1月初，地球离太阳距离最近，为1.471亿千米，这一点就是近日点。7月初地球离太阳最远，为1.52亿千米，这一点就是远日点。虽然近日点在1月并不代表1月是最热的，温度还跟阳光是否直射有关。 十一、地球五带：北寒带、北温带、热带、南温带、南寒带。 十二、最后放一张图片，如果顿悟该图片就会明白四季更替、极昼、极夜等地理知识：]]></content>
      <categories>
        <category>地理</category>
      </categories>
      <tags>
        <tag>地理</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态import来拆分代码后发布问题]]></title>
    <url>%2F2019%2F01%2F30%2Fdynamic-import-deploy-issue%2F</url>
    <content type="text"><![CDATA[当使用SPA（单页应用）的时候，为了提高性能，我们经常使用动态import来拆分代码。这种情况发布的时候可能会有这样的问题： 假如用户在发布前已经进入该应用，当用户在发布后再进入某个引入分片代码的的界面，那么很可能页面静态资源的路径是旧的，而服务器新发布的资源路径是新的（大多数路径不一样是文件名的hash值不同导致的，我们这里也假设是这样情况），那么两个路径不一样，从而导致404的发生。 我们这里讲一种简单的处理方法： 设置HTML不缓存 12&lt;meta http-equiv="Cache" content="no-cache"&gt;&lt;meta http-equiv="Cache-control" content="no-cache"&gt; 给动态引入的JS加上hash值，这一块不懂的可以看这篇文章 12//动态import处代码import(/* webpackChunkName: "[request]" */`../../containers/$&#123;requestPath&#125;`) 12345678//webpack.config.js//... 其他代码output: &#123; //... 其他代码 filename: '[name].[hash].js', chunkFilename: '[name].[hash].js',//这里使用hash,也可以是其他的hash具体按自己的项目来定&#125;,//... 其他代码 设置缓存头信息 1234//我这里使用的是koa2做为服务器的 根据使用的服务器来设置响应头信息就可以了app.use(require('koa-static')(__dirname + '/public',&#123; maxage:1209600000//这个时间根据具体的项目来自己定&#125;)) 通过上述步骤就可以了，当用户在发布后再进入某个引入分片代码的的界面，那么页面中的引用是旧的资源路径，由于页面有缓存那么不会报错。当用户新进入页面的时候（比如刷新一下）那么由于HTML文件是不缓存的，它引入的js也是新的路径，而分片路径也是新的，所以界面就不会报错了。 这里需要注意的一点就是服务端新发布的代码最好可以兼容一下旧的界面，比如旧的界面要报个错什么的。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>dynamic import</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack中动态import()打包后的文件名称定义]]></title>
    <url>%2F2019%2F01%2F30%2Fdynamic-import-named%2F</url>
    <content type="text"><![CDATA[动态import()打包出来文件的name是按照0,1,2...依次排列，如0.js、1.js等，有的时候我们希望打包出来的文件名是打包前的文件名称。要实现这，需要经历3个步骤：1.在webpack配置文件中的output中添加chunkFilename。命名规则根据自己的项目来定，其中[name]就是文件名，这一块更详细的说明请点击这里。1234567//其他代码...output: &#123; path: path.resolve(__dirname, 'public'), filename: '[name].[hash:8].js', chunkFilename: '[name].[hash:8].js',//动态import文件名&#125;,//其他代码... 2.在动态import()代码处添加注释webpackChunkName告诉webpack打包后的chunk的名称（注释中的内容很重要，不能省掉），这里打包以后的name就是MyFile。1import(/* webpackChunkName: "MyFile" */`../containers/MyFile`) 3.大多数情况下我们使用动态import()是通过循环来做的，这样我们就不得不引入变量了，使用[request]来告诉webpack，这里的值是根据后面传入的字符串来决定，本例中就是变量pathName的值，具体如下：1import(/* webpackChunkName: "[request]" */`../containers/$&#123;pathName&#125;`)]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>dynamic import</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS改变input光标颜色]]></title>
    <url>%2F2019%2F01%2F25%2Fcaret-color%2F</url>
    <content type="text"><![CDATA[我们可能会有改变input光标颜色的需求，谷歌浏览器的默认光标颜色是黑色的，我们可以看到GitHub上的光标却是白色，那么这个用CSS怎么改变呢? 这种效果有两种实现方式： 1.使用color来实现光标的颜色是继承自当前输入框字体的颜色，所以用color属性即可改变：123input&#123; color:red;&#125; 2.使用caret-color来实现上一种方式已经修改了光标的颜色但是字体的颜色也改变了，如果只想改变光标的颜色而不改变字体的颜色那就使用caret-color属性:123input&#123; caret-color:red;&#125;]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS语法</tag>
      </tags>
  </entry>
</search>
